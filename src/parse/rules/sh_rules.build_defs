""" Rules to 'build' shell scripts.

Note that these do pretty much nothing beyond collecting the files. In future we might
implement something more advanced (ala .sar files or whatever).
"""

_SH_BINARY_TMPL_PREFIX = """
unzip -qo $0 -d $(dirname $0)
""".replace('$', '\\\$').replace('"', '\\"')

_SH_BINARY_TMPL_SUFFIX = """
exit 0\n\
"""


def sh_library(name:str, src:str, deps:list=None, visibility:list=None, labels:list&features&tags=None):
    """Generates a shell script binary, essentially just the given source.

    Note that these are individually executable so can only have one source file each.
    This is a bit tedious and would be nice to improve sometime.

    Args:
      name (str): Name of the rule.
      src (str): Source file for the rule.
      deps (list): Dependencies of this rule.
      visibility (list): Visibility declaration of the rule.
      labels (list): List of labels.
    """
    return filegroup(
        name=name,
        srcs=[src],
        deps=deps,
        visibility=visibility,
        binary=True,
        labels=labels,
    )


def sh_binary(name:str, main:str, deps:list=None, visibility:list=None, labels:list&features&tags=None):
    """Generates a shell script binary.

    It assumes that unzip is in your path.

    The resulting script will contain three things:
    1) Code necessary to unzip dependent files.
    2) The user defined shell script.
    3) The zipfile containing all dependent files.

    Args:
      name (str): Name of the rule
      main (str): The script to execute after all files have been uncompressed
      deps (list): Dependencies of this rule
      visibility (list): Visibility declaration of the rule.
      labels (list): List of labels.
    """
    # No need to go through zip/unzip and injecting code if there are no dependencies
    if deps:
        cmds = ' && '.join([
            # Use the same shebang as the original script
            'head -1 $SRCS > _tmp.txt',
            # Inject bash code to untar the compressed files.
            'echo "%s" >> _tmp.txt' % _SH_BINARY_TMPL_PREFIX,
            # Inject the user defined script.
            'cat $SRCS >> _tmp.txt',
            # Inject a final exit so it doesn't try to execute the zipfile contents.
            'echo "%s" >> _tmp.txt' % _SH_BINARY_TMPL_SUFFIX,
            # Compress the dependent files and dump out into the bash script.
            'find . -type f | grep -v $SRCS | sort | grep -v "_tmp.txt" | $TOOL z -d -i - -o $OUT --preamble_file _tmp.txt --strip_prefix ./',
        ])
    else:
        cmds = 'cp $SRCS $OUT'

    return build_rule(
        name = name,
        srcs = [main],
        outs = ['%s.sh' % name],
        tools = [CONFIG.JARCAT_TOOL],
        cmd = cmds,
        deps = deps,
        binary = True,
        needs_transitive_deps = True,
        labels = labels,
        visibility = visibility,
    )


def sh_test(name:str, src:str=None, labels:list&features&tags=None, data:list=None, deps:list=None, worker:str='',
            size:str=None, visibility:list=None, flags:str='', flaky:bool|int=0, test_outputs:list=None, timeout:int=0,
            container:bool|dict=False, sandbox:bool=None):
    """Generates a shell test. Note that these aren't packaged in a useful way.

    Args:
      name (str): Name of the rule
      src (str): Test script file.
      labels (list): Labels to apply to this test.
      data (list): Runtime data for the test.
      deps (list): Dependencies of this rule
      worker(str): Reference to worker script, A persistent worker process that is used to set up the test.
      size (str): Test size (enormous, large, medium or small).
      visibility (list): Visibility declaration of the rule.
      flags (str): Flags to apply to the test invocation.
      timeout (int): Maximum length of time, in seconds, to allow this test to run for.
      flaky (int | bool): True to mark this as flaky and automatically rerun.
      test_outputs (list): Extra test output files to generate from this test.
      container (bool | dict): True to run this test within a container (eg. Docker).
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
    """
    timeout, labels = _test_size_and_timeout(size, timeout, labels)

    test_cmd = '$TEST %s' % flags
    if worker:
        test_cmd = '$(worker %s) && %s ' % (worker, test_cmd)
        deps += [worker]

    return build_rule(
        name=name,
        srcs=[src or test],
        data=data,
        deps=deps,
        outs=[name + '.sh'],
        cmd='mv ${SRC} ${OUT}',
        test_cmd=test_cmd,
        visibility=visibility,
        labels=labels,
        binary=True,
        test=True,
        no_test_output=True,
        flaky=flaky,
        test_outputs=test_outputs,
        test_timeout=timeout,
        container=container,
        test_sandbox=sandbox,
    )


def sh_cmd(name:str, cmd:str|dict, srcs:list|dict=None, out:list=None, shell:str='/bin/sh',
           labels:list&features&tags=None, deps:list=None, visibility:list=None):
    """Generates a runnable shell script from a command.

    This is doable with a genrule with a little effort but it's awkward enough to be nice
    to have a builtin.
    The command is subject to Please's usual variable expansion at build time. Note that if
    you want `plz run` to transparently work and refer to other files, you may need to use
    $(out_location ...) instead of $(location ...).

    Args:
      name (str): Name of the rule.
      cmd (str | dict): Command to write into the output script file.
      srcs (list | dict): Source files. Can be consumed by the generated command (but are not
                          written into the output in any other way).
      out (str): Name of the output file to create. Defaults to name + .sh.
      shell (str): Shell to invoke in, by default /bin/sh.
      labels (list): Labels to apply to this rule.
      deps (list): Any dependencies for this rule.
      visibility (list): Visibility declaration of the rule.
    """
    if isinstance(cmd, str):
        cmds = 'cat > $OUT << EOF\n#!%s\n%s\nEOF' % (shell, cmd)
    else:
        cmds = {k: 'cat > $OUT << EOF\n#!%s\n%s\nEOF' % (shell, v) for k, v in cmd.items()}
    return build_rule(
        name = name,
        outs = [out or name + '.sh'],
        srcs = srcs,
        cmd = cmds,
        labels = labels,
        deps = deps,
        visibility = visibility,
        binary = True,
    )
