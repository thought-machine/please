""" Rules to build Go code.

Go has a strong built-in concept of packages so it's probably a good idea to match Please
rules to Go packages.
"""

_GO_COMPILE_TOOL = 'compile' if CONFIG.GO_VERSION >= "1.5" else '6g'
_GO_LINK_TOOL = 'link' if CONFIG.GO_VERSION >= "1.5" else '6l'
_GOPATH = ' '.join('-I %s -I %s/pkg/%s_%s' % (p, p, CONFIG.OS, CONFIG.ARCH) for p in CONFIG.GOPATH.split(':'))

# This links all the .a files up one level. This is necessary for some Go tools to find them.
_LINK_PKGS_CMD = 'for i in `find . -name "*.a"`; do j=${i%/*}; ln -s $TMP_DIR/$i ${j%/*}; done'

# Commands for go_binary and go_test.
_LINK_CMD = 'go tool %s -tmpdir $TMP_DIR %s -L . -o ${OUT} ' % (_GO_LINK_TOOL, _GOPATH.replace('-I ', '-L '))
_GO_BINARY_CMDS = {
    'dbg': '%s && %s $SRCS' % (_LINK_PKGS_CMD, _LINK_CMD),
    'opt': '%s && %s -s -w $SRCS' % (_LINK_PKGS_CMD, _LINK_CMD),
}
_GO_STATIC_BINARY_CMDS = {
    'dbg': '%s && %s -linkmode external -extldflags "-static" $SRCS' % (_LINK_PKGS_CMD, _LINK_CMD),
    'opt': '%s && %s -linkmode external -extldflags "-static" -s -w $SRCS' % (_LINK_PKGS_CMD, _LINK_CMD),
}

# Commands for go_library, which differ a bit more by config.
_ALL_GO_LIBRARY_CMDS = {
    # Links archives up a directory; this is needed in some cases depending on whether
    # the library matches the name of the directory it's in or not.
    'link_cmd': _LINK_PKGS_CMD,
    # Invokes the Go compiler.
    'compile_cmd': 'go tool %s -trimpath $TMP_DIR -complete %s -pack -o $OUT ' % (_GO_COMPILE_TOOL, _GOPATH),
    # Annotates files for coverage
    'cover_cmd': 'for SRC in $SRCS; do mv -f $SRC _tmp.go; BN=$(basename $SRC); go tool cover -mode=set -var=GoCover_${BN//./_} _tmp.go > $SRC; done',
}
# String it all together.
_GO_LIBRARY_CMDS = {
    'dbg': '%(link_cmd)s && %(compile_cmd)s -N -l $SRCS' % _ALL_GO_LIBRARY_CMDS,
    'opt': '%(link_cmd)s && %(compile_cmd)s $SRCS' % _ALL_GO_LIBRARY_CMDS,
    'cover': '%(link_cmd)s && %(cover_cmd)s && %(compile_cmd)s $SRCS' % _ALL_GO_LIBRARY_CMDS,
}
# Applied to various rules to treat 'go' as a tool.
_GO_TOOL = ['go']


def go_library(name, srcs, out=None, deps=None, visibility=None, test_only=False,
               go_tools=None, complete=True, _needs_transitive_deps=False):
    """Generates a Go library which can be reused by other rules.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      out (str): Name of the output library to compile (defaults to name suffixed with .a)
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      go_tools (list): A list of targets to pre-process your src files with go generate.
      complete (bool): Indicates whether the library is complete or not (ie. buildable with
                       'go tool build -complete'). In nearly all cases this is True (the main
                       exception being for cgo).
    """
    deps = deps or []
    # go_test and cgo_library need access to the sources as well.
    filegroup(
        name='_%s#srcs' % name,
        srcs=srcs,
        exported_deps=deps,
        visibility=visibility,
        output_is_complete=False,
        requires=['go'],
        test_only=test_only,
    )

    # Run go generate if needed.
    if go_tools:
        go_generate(
            name='_%s#gen' % name,
            srcs=srcs,
            tools=go_tools,
            deps=deps + [':_%s#srcs' % name],
            test_only=test_only,
        )
        srcs += [':_%s#gen' % name]

    cmds = _GO_LIBRARY_CMDS
    if not complete:
        cmds = {k: v.replace('-complete ', '') for k, v in cmds.items()}

    build_rule(
        name=name,
        srcs=srcs,
        deps=deps + [':_%s#srcs' % name],
        outs=[out or name + '.a'],
        cmd=cmds,
        visibility=visibility,
        building_description="Compiling...",
        requires=['go'],
        provides={'go': ':' + name, 'go_src': ':_%s#srcs' % name},
        test_only=test_only,
        tools=_GO_TOOL,
        needs_transitive_deps=_needs_transitive_deps,
    )


def go_generate(name, srcs, tools, deps=None, visibility=None, test_only=False):
    """Generates a `go generate` rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to run go generate over.
      tools (list): A list of targets which represent binaries to be used via `go generate`.
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
    """
    # We simply capture all go files produced by go generate.
    def _post_build(rule_name, output):
        for out in output:
            if out.endswith('.go') and srcs and out not in srcs:
                add_out(rule_name, out)

    # All the tools must be in the $PATH.
    path = ':'.join('$(dirname $(location %s))' % tool for tool in tools)
    gopath = ' | '.join([
        'find . -type d -name src',
        'grep -v "^\.$"',
        'sed "s|^\.|$TMP_DIR|g"',
        'sed "/^\s*$/d"',
        'tr "\n" ":"',
        'sed -e "s/:$//" -e "s/src$//g"'
    ])
    cmd = ' && '.join([
        # It's essential that we copy all .a files up a directory as well; we tend to output them one level
        # down from where Go expects them to be.
        _LINK_PKGS_CMD,
        # It's also essential that the compiled .a files are under this prefix, otherwise gcimporter won't find them.
        'mkdir pkg',
        'ln -s $TMP_DIR pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH),
        'PATH="$PATH:%s" GOPATH="$TMP_DIR$(echo ":$(%s)" | sed "s/:$//g")" go generate $SRCS' % (path, gopath),
        'mv $PKG/*.go .',
        'ls *.go'
    ])
    build_rule(
        name=name,
        srcs=srcs,
        deps=deps,
        tools=_go_tool(tools),
        cmd=cmd,
        visibility=visibility,
        test_only=test_only,
        post_build=_post_build,
    )


def cgo_library(name, srcs, go_srcs=None, c_srcs=None, c_hdrs=None, out=None, flags=None,
                deps=None, visibility=None, test_only=False):
    """Generates a Go library which can be reused by other rules.

    Note that by its nature this is something of a hybrid of Go and C rules. It can depend
    on C / C++ rules, given the limitations of cgo (i.e. you will have to interact with them
    through a C interface, although the objects themselves can contain C++). As mentioned
    below, you will likely be better off wrapping your dependencies into a cc_static_library
    rule and depending on that rather than depending directly on cc_library rules.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile that have 'import "C"' declarations in them.
      go_srcs (list): Any Go source files that do *not* have 'import "C"' declarations.
      c_srcs (list): Any C source files to include.
      c_hdrs (list): Any C header files to include.
      out (str): Name of output file. Defaults to name + '.a'.
      flags (list): List of additional flags to pass to the go command.
      deps (list): Dependencies. Note that if you intend to depend on cc_library rules,
                   you will likely be better off wrapping them into a cc_static_library
                   and depending on that.
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
    """
    deps = deps or []
    go_srcs = go_srcs or []
    c_srcs = c_srcs or []
    c_hdrs = c_hdrs or []
    generated_go_srcs = [src.replace('.go', '.cgo1.go') for src in srcs] + ['_cgo_gotypes.go']
    generated_c_srcs = [src.replace('.go', '.cgo2.c') for src in srcs] + ['_cgo_export.c']
    generated_hdrs = ['_cgo_export.h']
    cgo_rule = build_rule(
        name = name,
        tag = 'cgo',
        srcs = srcs + c_hdrs,
        outs = [name + '_cgo'],
        cmd = 'mkdir $OUT && cd $PKG && $TOOL tool cgo -objdir $OUT -importpath ${PKG#*src/} *.go',
        tools = _GO_TOOL,
    )
    # Break up the outputs of the cgo rule into relevant bits.
    # TODO(pebers): This would be easier if we could indicate a dependency on a single
    #               output of a rule somehow...
    gen_go = _collect_files(name, 'gen_go', cgo_rule, generated_go_srcs)
    gen_c = _collect_files(name, 'gen_c', cgo_rule, generated_c_srcs)
    gen_h = _collect_files(name, 'gen_hdr', cgo_rule, generated_hdrs)
    # Compile the various bits
    c_library(
        name = '_%s#c' % name,
        srcs = [gen_c] + c_srcs,
        hdrs = [gen_h] + c_hdrs,
        compiler_flags = [
            '-Wno-unused-parameter',  # Generated code doesn't compile clean
            '-no-pie',  # go build passes this
        ],
        test_only = test_only,
        deps = deps,
    )
    # Recompile the output of the C rule into an ELF (or Mach-O or whatever) object.
    # Weirdly cgo has already generated something, but AFAICT Go's normal compilation
    # process basically ignores that and overwrites it again.
    cc_tool, tools = _tool_path(CONFIG.CC_TOOL)
    ar_tool, tools = _tool_path(CONFIG.AR_TOOL, tools)
    cgo_o_rule = build_rule(
        name = name,
        tag = 'cgo_o',
        srcs = [':_%s#c' % name],
        outs = [name + '_cgo.o'],
        cmd = '%s x $SRCS && %s -o $OUT -Wl,-r -fPIC -nostdlib *.o' % (ar_tool, cc_tool),
        requires = ['cc'],
        tools = tools,
    )
    # Now we run cgo *again* to produce the _cgo_import.go file.
    cgo_import_rule = build_rule(
        name = name,
        tag = 'cgo_import',
        srcs = [cgo_o_rule],
        outs = [name + '_cgo_import.go'],
        cmd = '$TOOL tool cgo -objdir . -dynpackage ${PKG#*src/} -dynimport $SRCS -dynout $OUT',
        tools = _GO_TOOL,
    )
    # Now we can finally compile the Go code with this new file
    go_library(
        name = '_%s#go' % name,
        srcs = [gen_go] + go_srcs,
        test_only = test_only,
        complete = False,
        deps = deps,
    )
    # And finally combine the compiled C code into the Go archive object so go tool link can find it later.
    build_rule(
        name = name,
        srcs = {
            'a': [':_%s#go' % name],
            'o': [cgo_o_rule],
        },
        outs = [name + '.a'],
        cmd = '$TOOL tool pack r $SRCS_A $SRCS_O && mv $SRCS_A $OUT',
        tools = _GO_TOOL,
        visibility = visibility,
        test_only = test_only,
    )


def go_binary(name, main=None, srcs=None, deps=None, visibility=None, test_only=False,
              static=False):
    """Compiles a Go binary.

    Args:
      name (str): Name of the rule.
      main (str): Go source file containing the main function.
      srcs (list): Go source files, one of which contains the main function.
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically -linkmode external -extldflags static).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Not yet tested against cgo.
    """
    go_library(
        name='_%s#lib' % name,
        srcs=srcs or [main or name + '.go'],
        deps=deps,
        test_only=test_only,
    )
    build_rule(
        name=name,
        srcs=[':_%s#lib' % name],
        deps=deps,
        outs=[name],
        cmd=_GO_STATIC_BINARY_CMDS if static else _GO_BINARY_CMDS,
        building_description="Linking...",
        needs_transitive_deps=True,
        binary=True,
        output_is_complete=True,
        test_only=test_only,
        tools=_GO_TOOL,
        visibility=visibility,
        requires=['go'],
    )


def go_test(name, srcs, data=None, deps=None, visibility=None, flags='', container=False,
            timeout=0, flaky=0, test_outputs=None, labels=None, size=None, mocks=None):
    """Defines a Go test rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      container (bool | dict): True to run this test in a container.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      mocks (dict): Dictionary of packages to mock, e.g. {"os": "//mocks:mock_os"}
                    They are replaced at link time, so it's only possible to mock complete packages.
                    Each build rule should be a go_library (or something equivalent).
    """
    deps = deps or []
    timeout, labels = _test_size_and_timeout(size, timeout, labels)
    # Unfortunately we have to recompile this to build the test together with its library.
    build_rule(
        name='_%s#lib' % name,
        srcs=srcs,
        deps=deps,
        outs=[name + '.a'],
        tools=_GO_TOOL,
        cmd={k: 'SRCS=${PKG}/*.go; ' + v for k, v in _GO_LIBRARY_CMDS.items()},
        building_description="Compiling...",
        requires=['go', 'go_src'],
        test_only=True,
        # TODO(pebers): We should be able to get away without this via a judicious
        #               exported_deps in go_library, but it doesn't seem to be working.
        needs_transitive_deps=True,
    )
    go_test_tool, tools = _tool_path(CONFIG.GO_TEST_TOOL)
    build_rule(
        name='_%s#main' % name,
        srcs=srcs,
        outs=[name + '_main.go'],
        deps=deps,
        cmd={
            'dbg': go_test_tool + ' -o $OUT $SRCS',
            'opt': go_test_tool + ' -o $OUT $SRCS',
            'cover': go_test_tool + ' -d . -o $OUT $SRCS ',
        },
        needs_transitive_deps=True,  # Need all .a files to template coverage variables
        requires=['go'],
        test_only=True,
        tools=tools,
        post_build=_replace_test_package,
    )
    deps.append(':_%s#lib' % name)
    go_library(
        name='_%s#main_lib' % name,
        srcs=[':_%s#main' % name],
        deps=deps,
        _needs_transitive_deps=True,  # Rather annoyingly this is only needed for coverage
        test_only=True,
    )
    cmds = _GO_BINARY_CMDS
    if mocks:
        cmds = cmds.copy()
        mocks = sorted(mocks.items())
        deps.extend(v for _, v in mocks)
        dirs = 'mkdir -p ' + ' '.join('$(dirname %s)' % k for k, _ in mocks)
        mvs = ' && '.join('mv $(location %s) %s.a' % (v, k) for k, v in mocks)
        for k, v in cmds.items():
            cmds[k] = ' && '.join([dirs, mvs, v])
    build_rule(
        name=name,
        srcs=[':_%s#main_lib' % name],
        data=data,
        deps=deps,
        outs=[name],
        tools=_GO_TOOL,
        cmd=cmds,
        test_cmd='$TEST %s | tee test.results' % flags,
        visibility=visibility,
        container=container,
        test_timeout=timeout,
        flaky=flaky,
        test_outputs=test_outputs,
        requires=['go'],
        labels=labels,
        binary=True,
        test=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
    )


def cgo_test(name, srcs, data=None, deps=None, visibility=None, flags='', container=False,
             timeout=0, flaky=0, test_outputs=None, labels=None, tags=None, size=None):
    """Defines a Go test rule for a library that uses cgo.

    If the library you are testing is a cgo_library, you must use this instead of go_test.
    It's ok to depend on a cgo_library though as long as it's not the same package
    as your test.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      container (bool | dict): True to run this test in a container.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      tags (list): Tags to pass to go build (see 'go help build' for details).
      size (str): Test size (enormous, large, medium or small).
    """
    cc_tool, tools = _tool_path(CONFIG.CGO_CC_TOOL, _GO_TOOL)
    timeout, labels = _test_size_and_timeout(size, timeout, labels)
    tag_cmd = '-tags "%s"' % ' '.join(tags) if tags else ''
    cmd = 'export GOPATH="%s"; ln -s $TMP_DIR src; CC="%s" go test ${PKG#*src/} %s -c -o $OUT' % (CONFIG.GOPATH, cc_tool, tag_cmd)
    test_cmd = '$TEST -test.v -test.coverprofile test.coverage | tee test.results'
    build_rule(
        name=name,
        srcs=srcs,
        data=data,
        deps=deps,
        outs=[name],
        tools=tools,
        cmd={
            'cover': cmd + ' -test.cover -tags cover',
            'opt': cmd,
        },
        test_cmd={
            'cover': '$TEST -test.v -test.coverprofile test.coverage %s | tee test.results' % flags,
            'opt': '$TEST -test.v %s | tee test.results' % flags,
        },
        visibility=visibility,
        container=container,
        test_timeout=timeout,
        flaky=flaky,
        test_outputs=test_outputs,
        requires=['go', 'go_src'],
        labels=labels,
        binary=True,
        test=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
    )


def go_get(name, get=None, outs=None, deps=None, exported_deps=None, visibility=None, patch=None,
           binary=False, test_only=False, install=None, revision=None, strip=None):
    """Defines a dependency on a third-party Go library.

    Args:
      name (str): Name of the rule
      get (str): Target to get (eg. "github.com/gorilla/mux")
      outs (list): Output files from the rule. Default autodetects.
      deps (list): Dependencies
      exported_deps (list): Dependencies to make available to anything using this rule.
      visibility (list): Visibility specification
      patch (str): Patch file to apply
      binary (bool): True if the output of the rule is a binary.
      test_only (bool): If true this rule will only be visible to tests.
      install (list): Allows specifying extra packages to install. Convenient in some cases where we
                      want to go get something with an extra subpackage.
      revision (str): Git hash to check out before building. Only works for git at present,
                      not for other version control systems.
      strip (list): List of paths to strip from the installed target.
    """
    post_build = None
    if binary and outs and len(outs) != 1:
        raise ValueError(name + ': Binary rules can only have a single output')
    if not outs:
        outs = [('bin/' + name) if binary else ('src/' + get)]
        if not binary:
            post_build = _extra_outs(get)
    cmd = [
        'export GOPATH=$TMP_DIR:$TMP_DIR/$PKG',
        'rm -rf pkg src',
        'go get -d ' + get,
    ]
    subdir = 'src/' + (get[:-4] if get.endswith('/...') else get)
    if revision:
        # Annoyingly -C does not work on git checkout :(
        cmd.append('(cd %s && git checkout -q %s)' % (subdir, revision))
    if patch:
        cmd.append('patch -s -d %s -p1 < ${TMP_DIR}/$(location %s)' % (subdir, patch))
    cmd.append('go install -gcflags "-trimpath $TMP_DIR" ' + ' '.join([get] + (install or [])))
    # Remove anything that was there already.
    cmd.append('if [ -d $PKG ]; then find $PKG -name "*.a" | sed -e "s|$PKG/||g" | xargs rm -f; fi')
    if not binary:
        cmd.extend([
            'find . -name .git | xargs rm -rf',
            'find pkg -name "*.a" | sort',
        ])
    if strip:
        cmd.extend('rm -rf %s/%s' % (subdir, s) for s in strip)
    build_rule(
        name=name,
        srcs=[patch] if patch else [],
        outs=outs,
        deps=deps,
        exported_deps=exported_deps,
        tools=_GO_TOOL,
        visibility=visibility,
        building_description='Fetching...',
        cmd=' && '.join(cmd),
        binary=binary,
        requires=['go'],
        test_only=test_only,
        post_build=post_build,
    )


def go_yacc(name, src, out=None, visibility=None, labels=None):
    """Defines a rule that invokes 'go tool yacc' to generate Go source using yacc.

    Args:
      name (str): Name of the rule.
      src (str): Source file for the rule. There can be only one.
      out (str): Output file for the rule. Defaults to name + '.yacc.go'.
      visibility (list): Visibility specification.
      labels (list): Labels for this rule.
    """
    build_rule(
        name = name,
        srcs = [src],
        outs = [out or name + '.yacc.go'],
        tools = _GO_TOOL,
        cmd = 'go tool yacc -o $OUT $SRC',
        building_description = 'yaccing...',
        visibility = visibility,
        labels = labels,
        requires = ['go'],
    )


def _extra_outs(get):
    """Attaches extra outputs to go_get rules."""
    def _inner(name, output):
        last = '<>'
        for archive in output:
            try:
                add_out(name, archive)
                subpath = archive[archive.find('/', 6) + 1:-2]
                if (not subpath.startswith(get) and not subpath.startswith(last) and
                    not get.startswith(subpath) and not last.startswith(subpath)):
                        add_out(name, 'src/' + subpath)
            except ParseError:
                log.error("Looks like you have two go_get rules trying to output the "
                          "same file; most likely you need to add some dependencies so "
                          "that shared file is built independently.")
                raise
            last = subpath
    return _inner


def _replace_test_package(name, output):
    """Post-build function, called after we template the main function.

    The purpose is to replace the real library with the specific one we've
    built for this test which has the actual test functions in it.
    """
    if not name.endswith('#main') or not name.startswith('_'):
        raise ValueError('unexpected rule name: ' + name)
    lib = name[:-5] + '#main_lib'
    name = name[1:-5]
    for line in output:
        if line.startswith('Package: '):
            for k, v in _GO_BINARY_CMDS.items():
                set_command(name, k, 'mv -f ${PKG}/%s.a ${PKG}/%s.a && %s' % (name, line[9:], v))
            for k, v in _GO_LIBRARY_CMDS.items():
                set_command(lib, k, 'mv -f ${PKG}/%s.a ${PKG}/%s.a && %s' % (name, line[9:], v))


def _go_tool(tools):
    """Returns the given list annotated with the 'go' tool.

    Currently the tool invoked for 'go' is not configurable.
    """
    return (tools or []) + ['go']


def _collect_files(name, tag, dep, outs):
    """Defines a rule to collect a subset of outputs from another rule.

    Used mostly for cgo which spits out many different kinds of thing.
    """
    return build_rule(
        name = name,
        tag = tag,
        srcs = [dep],
        outs = outs,
        cmd = 'mv $PKG/%s_cgo/* .' % name,
    )
