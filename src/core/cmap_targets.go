// This file was originally generated by genx (https://github.com/OneOfOne/genx)
// but has a large set of manual changes made later, and hence is more inspired by
// the original than generated from it.

package core

import (
	"sync"

	"github.com/OneOfOne/cmap/hashers"
)

// shardCount must be a power of 2.
// Higher shardCount will improve concurrency but will consume more memory.
const shardCount = 1 << 8

// shardMask is the mask we apply to hash functions below.
const shardMask = shardCount - 1

// targetMap is a concurrent safe sharded map to scale on multiple cores.
// It's a fully specialised version of cmap.CMap for our most commonly used types.
type targetMap struct {
	shards []*targetLMap
}

// newTargetMap creates a new targetMap.
func newTargetMap() *targetMap {
	cm := &targetMap{
		shards: make([]*targetLMap, shardCount),
	}
	for i := range cm.shards {
		cm.shards[i] = newTargetLMapSize(shardCount)
	}
	return cm
}

// Set is the equivalent of `map[key] = val`.
// It returns true if the item was inserted, false if it already existed (in which case it won't be inserted)
func (cm *targetMap) Set(target *BuildTarget) bool {
	h := hashBuildLabel(target.Label)
	return cm.shards[h&shardMask].Set(target)
}

// Get returns the target or, if the target isn't present, a channel that it can be waited on for.
// Exactly one of the target or channel will be returned.
func (cm *targetMap) Get(key BuildLabel) (val *BuildTarget, wait <-chan struct{}) {
	h := hashBuildLabel(key)
	return cm.shards[h&shardMask].Get(key)
}

// Values returns a slice of all the current values in the map.
// This is a view that an observer could potentially have had at some point around the calling of this function,
// but no particular consistency guarantees are made.
func (cm *targetMap) Values() BuildTargets {
	ret := BuildTargets{}
	for _, lm := range cm.shards {
		ret = append(ret, lm.Values()...)
	}
	return ret
}

func hashBuildLabel(key BuildLabel) uint32 {
	return hashers.Fnv32(key.Subrepo) ^ hashers.Fnv32(key.PackageName) ^ hashers.Fnv32(key.Name)
}

// A buildTargetPair represents a build target & an awaitable channel for one to exist.
type buildTargetPair struct {
	Target *BuildTarget
	Wait   chan struct{}
}

// targetLMap is a simple sync.Mutex locked map.
// Used by targetMap internally for sharding.
type targetLMap struct {
	m map[BuildLabel]buildTargetPair
	l sync.Mutex
}

// newTargetLMapSize is the equivalent of `m := make(map[BuildLabel]buildTargetPair, cap)`
func newTargetLMapSize(cap int) *targetLMap {
	return &targetLMap{
		m: make(map[BuildLabel]buildTargetPair, cap),
	}
}

// Set is the equivalent of `map[key] = val`.
// It returns true if the item was inserted, false if it already existed (in which case it won't be inserted)
func (lm *targetLMap) Set(target *BuildTarget) bool {
	lm.l.Lock()
	defer lm.l.Unlock()
	if existing, present := lm.m[target.Label]; present {
		if existing.Target != nil {
			return false  // already added
		}
		// Hasn't been added, but something is waiting for it to be.
		lm.m[target.Label] = buildTargetPair{Target: target}
		if existing.Wait != nil {
			close(existing.Wait)
		}
		return true
	}
	lm.m[target.Label] = buildTargetPair{Target: target}
	return true
}

// Get returns the target or, if the target isn't present, a channel that it can be waited on for.
// Exactly one of the target or channel will be returned.
func (lm *targetLMap) Get(key BuildLabel) (*BuildTarget, <-chan struct{}) {
	lm.l.Lock()
	defer lm.l.Unlock()
	if v, ok := lm.m[key]; ok {
		return v.Target, v.Wait
	}
	// Need to check again; something else could have added this.
	if v, ok := lm.m[key]; ok {
		return v.Target, v.Wait
	}
	ch := make(chan struct{})
	lm.m[key] = buildTargetPair{Wait: ch}
	return nil, ch
}

// Values returns a copy of all the targets currently in the map.
func (lm *targetLMap) Values() []*BuildTarget {
	lm.l.Lock()
	defer lm.l.Unlock()
	ret := make([]*BuildTarget, 0, len(lm.m))
	for _, v := range lm.m {
		if v.Target != nil {
			ret = append(ret, v.Target)
		}
	}
	return ret
}
