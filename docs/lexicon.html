    <h1>The Lexicon of Please</h1>

    <p>This is the reference for the complete set of builtin rules & functions.</p>

    <h2><a name="builtins">Builtin functions</a></h2>

    <h3><a name="subinclude">subinclude</a></h3>

    <p><pre class="rule"><code>subinclude(target)</code></pre></p>

    <p>Includes the output of a build target as extra rules in this one.</p>

    <p>This is the closest equivalent to <code>import</code> in the BUILD language. It behaves
      somewhat differently though in that the contents of the subincluded file are added to the
      globals of the current module so can be called directly.</p>

    <p>The target that you attempt to subinclude is simply a normal build target, with the
      restriction that it must have exactly one output. The simplest form of this is a single-file
      <a href="#filegroup">filegroup</a> or <a href="export_file">export_file</a> rule, but
      it is possible to have more complex rules generating your BUILD definitions.</p>

    <p>For example:

    <pre><code>subinclude('//build_defs:my_build_rules')</code></pre>
    </p>

    <p>Note that you can also <code>subinclude</code> remote files as follows:

    <pre><code>subinclude('https://raw.githubusercontent.com/thought-machine/pleasings/master/grm/grm.build_defs')</code></pre>

    These are deduplicated internally so they're only downloaded & parsed once, so it's reasonably
    performant, although it's still often preferable to vendorise them yourself.</p>

    <h3><a name="glob">glob</a></h3>

    <p><pre class="rule"><code>glob(includes, excludes=None, hidden=False)</code></pre></p>

    <p>Matches all filenames by a pattern, in a manner reminiscent of shell-style pattern
      expansion or Python's builtin <a href="https://docs.python.org/3/library/glob.html">glob</a>
      module.</p>

    <p>Note that the only expansion patterns accepted are <code>*</code> to match an arbitrary
      number of non-separator characters (i.e. not <code>/</code>), and <code>**</code> to
      match any number of <b>complete</b> path components.<br/>
      These are often referred to as &quot;Ant-style&quot; patterns since Ant introduced them.</p>

    <p>It bears noting that you cannot glob generated files, only source files. Also glob will not
      descend into any directories that contain a BUILD file; this maintains an invariant that
      each file is owned by exactly one package (or potentially none, but then Please doesn't know
      or care about them). If you want to pull in files from another package, export them there
      using a <a href="#filegroup"><code>filegroup</code></a> and depend on that in the package
      you want it.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>includes</td>
	<td></td>
	<td>list</td>
	<td>List of paths to include. Each is globbed separately.</td>
      </tr>

      <tr>
	<td>excludes</td>
	<td>None</td>
	<td>list</td>
	<td>List of filenames to exclude from any patterns matched by <code>includes</code>.<br/>
      These are subject to glob expansion of <code>*</code> themselves, but
      <code>**</code> is <b>not</b> expanded (although since these are applied to each file found
      individually, it's not necessary).</td>
      </tr>

      <tr>
	<td>hidden</td>
	<td>False</td>
	<td>bool</td>
	<td>Set to True to include hidden files / folders.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="get_labels">get_labels</a></h3>

    <p><pre class="rule"><code>get_labels(target, prefix)</code></pre></p>

    <p>Gets the unique set of labels for a rule and all its transitive dependencies.</p>

    <p>Two formats are accepted for target: the first is a string containing just the target name,
      which is resolved in the current package. This facilitates calling them from a pre-build
      function, which is in fact the only time it's safe to call this way.<br/>
      The other is a full build target, which should be a transitive dependency of the target
      whose pre/post build function you're in. If the target isn't built when you ask for the
      labels the build will terminate.<br/>
      In either case this is only safe to call from a pre / post-build function and should
      never be called at initial parse time, because at that point you generally don't have
      the full set of labels available yet.</p>

    <p>Uses for this are normally fairly language-specific. The clearest example is maybe the
      builtin Python rules, where <code>python_binary</code> and <code>python_test</code> use
      this to identify if any of their dependencies have marked them as not being zip-safe.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>target</td>
	<td></td>
	<td>str</td>
	<td>Label of the target to get labels for.</td>
      </tr>

      <tr>
	<td>prefix</td>
	<td>None</td>
	<td>str</td>
	<td>Filters the returned labels to only ones starting with this prefix.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="has_label">has_label</a></h3>

    <p><pre class="rule"><code>has_label(target, prefix)</code></pre></p>

    <p>Returns True if the target has any matching label that would be returned by get_labels.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>target</td>
	<td></td>
	<td>str</td>
	<td>Label of the target to get labels for.</td>
      </tr>

      <tr>
	<td>prefix</td>
	<td>None</td>
	<td>str</td>
	<td>Checks only labels that start with this prefix.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="package">package</a></h3>

    <p><pre class="rule"><code>package(**kwargs)</code></pre></p>

    <p>Defines settings affecting the current package - for example, default visibility.</p>

    <p>With this you can override any current value in <code>CONFIG</code> by name for all
      subsequent targets in the current package. Only existing values can be replaced.</p>

    <p>There are also a couple of special values which aren't normally in <code>CONFIG</code>:
      <code>default_licences</code> and <code>default_visibility</code>. As the names suggest
      these set defaults for those attributes for all following targets that don't set them.</p>

    <p>This function must be called <b>before</b> any targets are defined.</p>

    <h3><a name="log">log</a></h3>

    <p><pre class="rule"><code>log.warning(message, [args...])</code></pre></p>

    <p>Logs an arbitrary message at some given level. The available levels, from most quiet
      to most severe, are:
      <ul>
        <li><code>log.debug</code></li>
        <li><code>log.info</code></li>
        <li><code>log.notice</code></li>
        <li><code>log.warning</code></li>
        <li><code>log.error</code></li>
        <li><code>log.fatal</code></li>
      </ul>
      These correspond to Please's built in messages and are controlled as usual by the
      <code>-v</code> command-line argument.</p>

    <p>As the name suggests, <code>log.fatal</code> immediately terminates the program with
      a fatal error. The others have no side effect other than showing the message.</p>

    <p>The message and arguments together are interpolated like Python's normal string
      interpolation, similar to the builtin <code>logging</code> package.</p>

    <h2><a name="cc">C and C++ rules</a></h2>

    <p>Rules to build C and C++ targets.</p>
    <p>The process of building C or C++ code is fairly complex so while these rules do their best
      to keep things reasonably simple, there's a lot of scope for things going wrong.</p>
    <p>There is very little difference between the <code>c_</code> and <code>cc_</code> variants
      of each rule, in nearly all cases they simply use different tools and flags in the
      <a href="config.html#cpp">relevant config section</a>.</p>

    <h3><a name="cc_library">c_library / cc_library</a></h3>

    <p><pre class="rule"><code>cc_library(name, srcs=None, hdrs=None, deps=None, visibility=None, test_only=False, compiler_flags=None, linker_flags=None, pkg_config_libs=None, archive=False)</code></pre></p>

    <p>Generate a C++ library target.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>C or C++ source files to compile.</td>
      </tr>

      <tr>
	<td>hdrs</td>
	<td>None</td>
	<td>list</td>
	<td>Header files. These will be made available to dependent rules, so the distinction
between srcs and hdrs is important.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependent rules.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration for this rule.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only available to other test rules.</td>
      </tr>

      <tr>
	<td>compiler_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the compiler.</td>
      </tr>

      <tr>
	<td>linker_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the linker; these will not be used here but will be
picked up by a cc_binary or cc_test rule.</td>
      </tr>

      <tr>
	<td>pkg_config_libs</td>
	<td>None</td>
	<td>list</td>
	<td>Libraries to declare a dependency on using pkg-config. Again, the ldflags
will be picked up by cc_binary or cc_test rules.</td>
      </tr>

      <tr>
	<td>alwayslink</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, any binaries / tests using this library will link in all symbols,
	  even if they don't directly reference them. This is useful for e.g. having
          static members that register themselves at construction time.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cc_static_library">c_static_library / cc_static_library</a></h3>

    <p><pre class="rule"><code>cc_static_library(name, srcs=None, hdrs=None, compiler_flags=None, linker_flags=None, deps=None, visibility=None, test_only=False, pkg_config_libs=None)</code></pre></p>

    <p>Generates a C++ static library (.a).</p>
    <p>
This is essentially just a collection of other cc_library rules into a single archive.</p>
    <p>Optionally this rule can have sources of its own, but it's quite reasonable just to use
it as a collection of other rules.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>C or C++ source files to compile.</td>
      </tr>

      <tr>
	<td>hdrs</td>
	<td>None</td>
	<td>list</td>
	<td>Header files.</td>
      </tr>

      <tr>
	<td>compiler_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the compiler.</td>
      </tr>

      <tr>
	<td>linker_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the linker.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependent rules.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration for this rule.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only available to other test rules.</td>
      </tr>

      <tr>
	<td>pkg_config_libs</td>
	<td>None</td>
	<td>list</td>
	<td>Libraries to declare a dependency on using pkg-config.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cc_shared_object">c_shared_object / cc_shared_object</a></h3>

    <p><pre class="rule"><code>cc_shared_object(name, srcs=None, hdrs=None, compiler_flags=None, linker_flags=None, deps=None, visibility=None, test_only=False, pkg_config_libs=None)</code></pre></p>

    <p>Generates a C++ shared object with its dependencies linked in.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>C or C++ source files to compile.</td>
      </tr>

      <tr>
	<td>hdrs</td>
	<td>None</td>
	<td>list</td>
	<td>Header files. These will be made available to dependent rules, so the distinction
between srcs and hdrs is important.</td>
      </tr>

      <tr>
	<td>out</td>
	<td></td>
	<td>str</td>
	<td>Name of the output file. Defaults to name + '.so'.</td>
      </tr>

      <tr>
	<td>compiler_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the compiler.</td>
      </tr>

      <tr>
	<td>linker_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the linker.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependent rules.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration for this rule.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only available to other test rules.</td>
      </tr>

      <tr>
	<td>pkg_config_libs</td>
	<td>None</td>
	<td>list</td>
	<td>Libraries to declare a dependency on using pkg-config.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cc_binary">c_binary / cc_binary</a></h3>

    <p><pre class="rule"><code>cc_binary(name, srcs=None, hdrs=None, compiler_flags=None, linker_flags=None, deps=None, visibility=None, pkg_config_libs=None)</code></pre></p>

    <p>Builds a binary from a collection of C++ rules.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>C or C++ source files to compile.</td>
      </tr>

      <tr>
	<td>hdrs</td>
	<td>None</td>
	<td>list</td>
	<td>Header files.</td>
      </tr>

      <tr>
	<td>compiler_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the compiler.</td>
      </tr>

      <tr>
	<td>linker_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the linker.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependent rules.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration for this rule.</td>
      </tr>

      <tr>
	<td>pkg_config_libs</td>
	<td>None</td>
	<td>list</td>
	<td>Libraries to declare a dependency on using pkg-config.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, this binary can only be used by test rules or other test_only rules.</td>
      </tr>

      <tr>
	<td>static</td>
	<td>False</td>
	<td>bool</td>
	<td>Attempts to compile a static binary. Default is false for dynamic linking, but note that
      in either case the repo-internal libraries will still be linked statically.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cc_test">c_test / cc_test</a></h3>

    <p><pre class="rule"><code>cc_test(name, srcs=None, compiler_flags=None, linker_flags=None, pkg_config_libs=None, deps=None, data=None, visibility=None, labels=None, flaky=False, test_outputs=None, timeout=0, container=False, write_main=True)</code></pre></p>

    <p>Defines a C++ test using UnitTest++.</p>
    <p>If <code>write_main</code> is true (the default for C++) then we template in a main file so you don't have to supply your own.</p>
    <p>Later we might add support for other test frameworks, for now you can add your own by setting <code>write_main=False</code>
      and writing your own <code>main</code> function.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>C or C++ source files to compile.</td>
      </tr>

      <tr>
	<td>compiler_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the compiler.</td>
      </tr>

      <tr>
	<td>linker_flags</td>
	<td>None</td>
	<td>list</td>
	<td>Flags to pass to the linker.</td>
      </tr>

      <tr>
	<td>pkg_config_libs</td>
	<td>None</td>
	<td>list</td>
	<td>Libraries to declare a dependency on using pkg-config.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependent rules.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for this test.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration for this rule.</td>
      </tr>

      <tr>
	<td>flags</td>
	<td></td>
	<td>str</td>
	<td>Flags to apply to the test invocation - i.e. passed on the command line when it's run.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to attach to this test.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>bool | int</td>
	<td>If true the test will be marked as flaky and automatically retried.</td>
      </tr>

      <tr>
	<td>test_outputs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra test output files to generate from this test.</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Length of time in seconds to allow the test to run for before killing it.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>If true the test is run in a container (eg. Docker).</td>
      </tr>

      <tr>
	<td>write_main</td>
	<td>True for <code>cc_test</code>, False for <code>c_test</code></td>
	<td>bool</td>
	<td>If true then a <code>main</code> function is written automatically for you.<br/>
      This will only work in C++ mode since it uses UnitTest++.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cc_embed_binary">c_embed_binary / cc_embed_binary</a></h3>

    <p><pre class="rule"><code>cc_embed_binary(name, src, deps=None, visibility=None, test_only=False, namespace=None)</code></pre></p>

    <p>Build rule to embed an arbitrary binary file into a C library.</p>
    <p>
You can depend on the output of this as though it were a cc_library rule.</p>
    <p>There are five functions available to access the data once compiled, all of which are
      prefixed with the file's basename:<br/>
      <ul>
	<li><code>filename_start()</code>: returns a const char* pointing to the beginning of the data.</li>
	<li><code>filename_end()</code>: returns a const char* pointing to the end of the data.</li>
	<li><code>filename_size()</code>: returns the length of the data in bytes.</li>
	<li><code>filename_start_nc()</code>: returns a char* pointing to the beginning of the data.<br/>
	  This is a convenience wrapper using const_cast, you should not
	  mutate the contents of the returned pointer.</li>
	<li><code>filename_end_nc()</code>: returns a char* pointing to the end of the data.<br/>
	  Again, don't mutate the contents of the pointer.</li>
      </ul>
    </p>
    <p>You don't own the contents of any of these pointers so don't try to delete them :)</p>
    <p>N.B. The implementation on OSX requires nasm, because Apple's ld doesn't support
      binary embedding. On other platforms it simply uses ld.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>src</td>
	<td></td>
	<td>str</td>
	<td>Source file to embed.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Rule visibility.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only available to test rules.</td>
      </tr>

      <tr>
	<td>namespace</td>
	<td>None</td>
	<td>str</td>
	<td>Allows specifying the namespace the symbols will be available in.<br/>
	  If not given you'll have to set it in <code>.plzconfig</code></td>
      </tr>

      </tbody>
    </table>

    <h2><a name="go">Go rules</a></h2>

    <p>Rules to build Go code.</p>
    <p>
Go has a strong built-in concept of packages so it's probably a good idea to match Please
rules to Go packages.</p>

    <h3><a name="go_library">go_library</a></h3>

    <p><pre class="rule"><code>go_library(name, srcs, out=None, deps=None, visibility=None, test_only=False, go_tools=None)</code></pre></p>

    <p>Generates a Go library which can be reused by other rules.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Go source files to compile.</td>
      </tr>

      <tr>
	<td>out</td>
	<td>None</td>
	<td>str</td>
	<td>Name of the output library to compile (defaults to name suffixed with .a)</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only visible to test rules.</td>
      </tr>

      <tr>
	<td>go_tools</td>
	<td>None</td>
	<td>list</td>
	<td>A list of targets to pre-process your src files with go generate.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="go_generate">go_generate</a></h3>

    <p><pre class="rule"><code>go_generate(name, srcs, tools, deps=None, visibility=None)</code></pre></p>

    <p>Generates a `go generate` rule.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Go source files to run go generate over.</td>
      </tr>

      <tr>
	<td>tools</td>
	<td></td>
	<td>list</td>
	<td>A list of targets which represent binaries to be used via `go generate`.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cgo_library">cgo_library</a></h3>

    <p><pre class="rule"><code>cgo_library(name, srcs, go_srcs, c_srcs, hdrs, env=None, deps=None, visibility=None, test_only=False, package)</code></pre></p>

    <p>Generates a Go library which can be reused by other rules.</p>
    <p>
    Note that by its nature this is something of a hybrid of Go and C rules. It can depend
    on C / C++ rules, given the limitations of cgo (i.e. you will have to interact with them
    through a C interface, although the objects themselves can contain C++). As mentioned
    below, you will likely be better off wrapping your dependencies into a cc_static_library
    rule and depending on that rather than depending directly on cc_library rules.</p>

    <p>Note also that this does not honour Go's syntactic comments; you have to explicitly
    specify which Go files are cgo vs. which are not, as well as C headers & sources and
    any required cflags or ldflags.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Go source files to compile that have 'import "C"' declarations in them.</td>
      </tr>

      <tr>
	<td>go_srcs</td>
	<td></td>
	<td>list</td>
	<td>Go source files to compile that do <b>not</b> have 'import "C"' declarations.</td>
      </tr>

      <tr>
	<td>hdrs</td>
	<td></td>
	<td>list</td>
	<td>Any C header files to include.</td>
      </tr>

      <tr>
	<td>c_srcs</td>
	<td></td>
	<td>list</td>
	<td>Any C source files to include.</td>
      </tr>

      <tr>
	<td>out</td>
	<td>None</td>
	<td>str</td>
	<td>Name of the output file. Defaults to name + '.a'.</td>
      </tr>

      <tr>
	<td>compiler_flags</td>
	<td>None</td>
	<td>list</td>
	<td>List of compiler flags to be passed when compiling the C code.<br/>
      Roughly equivalent to <code>cgo CFLAGS</code> directives in source files.</td>
      </tr>

      <tr>
	<td>linker_flags</td>
	<td>None</td>
	<td>list</td>
	<td>List of linker flags to be passed when linking the C code.<br/>
      Roughly equivalent to <code>cgo LDFLAGS</code> directives in source files.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies<br/>
	  Note that if you intend to depend on cc_library rules,
          you will likely be better off wrapping them into a cc_static_library
          and depending on that.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only visible to test rules.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="go_binary">go_binary</a></h3>

    <p><pre class="rule"><code>go_binary(name, main=None, deps=None, visibility=None, test_only=False)</code></pre></p>

    <p>Compiles a Go binary.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>main</td>
	<td>None</td>
	<td>str</td>
	<td>Deprecated, prefer <code>srcs</code> instead.<br/>
      Go source file containing the main function.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, is only visible to test rules.</td>
      </tr>

      <tr>
	<td>static</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, passes flags to the linker to try to force fully static linking.
      (specifically -linkmode external -extldflags static).
      Typically this increases size & link time a little but in return the binary
      has absolutely no external dependencies.
      Not yet tested against cgo.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="go_test">go_test</a></h3>

    <p><pre class="rule"><code>go_test(name, srcs, data=None, deps=None, visibility=None, container=False, timeout=0, flaky=False, test_outputs=None, labels=None)</code></pre></p>

    <p>Defines a Go test rule.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Go source files to compile.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for the test.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      <tr>
	<td>flags</td>
	<td></td>
	<td>str</td>
	<td>Flags to apply to the test invocation - i.e. passed on the command line when it's run.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>True to run this test in a container.</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Timeout in seconds to allow the test to run for.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>int | bool</td>
	<td>True to mark the test as flaky, or an integer to specify how many reruns.</td>
      </tr>

      <tr>
	<td>test_outputs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra test output files to generate from this test.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels for this rule.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="cgo_test">cgo_test</a></h3>

    <p><pre class="rule"><code>cgo_test(name, srcs, data=None, deps=None, visibility=None, container=False, timeout=0, flaky=False, test_outputs=None, labels=None, tags=None)</code></pre></p>

    <p>Defines a Go test rule for a library that uses cgo.</p>
    <p>
If the library you are testing is a cgo_library, you must use this instead of go_test.</p>
    <p>It's ok to depend on a cgo_library though as long as it's not the same package
as your test.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Go source files to compile.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for the test.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      <tr>
	<td>flags</td>
	<td></td>
	<td>str</td>
	<td>Flags to apply to the test invocation - i.e. passed on the command line when it's run.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>True to run this test in a container.</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Timeout in seconds to allow the test to run for.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>int | bool</td>
	<td>True to mark the test as flaky, or an integer to specify how many reruns.</td>
      </tr>

      <tr>
	<td>test_outputs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra test output files to generate from this test.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels for this rule.</td>
      </tr>

      <tr>
	<td>tags</td>
	<td>None</td>
	<td>list</td>
	<td>Tags to pass to go build (see 'go help build' for details).</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="go_get">go_get</a></h3>

    <p><pre class="rule"><code>go_get(name, get=None, outs=None, deps=None, visibility=None, patch=None, binary=False, test_only=False, install=None, revision=None)</code></pre></p>

    <p>Defines a dependency on a third-party Go library.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>get</td>
	<td>None</td>
	<td>str</td>
	<td>Target to get (eg. "github.com/gorilla/mux")</td>
      </tr>

      <tr>
	<td>outs</td>
	<td>None</td>
	<td>list</td>
	<td>Output files from the rule. Default autodetects.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification</td>
      </tr>

      <tr>
	<td>patch</td>
	<td>None</td>
	<td>str</td>
	<td>Patch file to apply</td>
      </tr>

      <tr>
	<td>binary</td>
	<td>False</td>
	<td>bool</td>
	<td>True if the output of the rule is a binary.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If true this rule will only be visible to tests.</td>
      </tr>

      <tr>
	<td>install</td>
	<td>None</td>
	<td>list</td>
	<td>Allows specifying extra packages to install. Convenient in some cases where we
want to go get something with an extra subpackage.</td>
      </tr>

      <tr>
	<td>revision</td>
	<td>None</td>
	<td>str</td>
	<td>Git hash to check out before building. Only works for git at present,
not for other version control systems.</td>
      </tr>

      </tbody>
    </table>

    <h2><a name="java">Java rules</a></h2>

    <p>Built-in rules to compile Java code.</p>

    <h3><a name="java_library">java_library</a></h3>

    <p><pre class="rule"><code>java_library(name, srcs=None, resources=None, resources_root=None, deps=None, exported_deps=None, visibility=None, source=None, target=None, test_only=False)</code></pre></p>

    <p>Compiles Java source to a .jar which can be collected by other rules.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>Java source files to compile for this library</td>
      </tr>

      <tr>
	<td>resources</td>
	<td>None</td>
	<td>list</td>
	<td>Resources to include in the .jar file</td>
      </tr>

      <tr>
	<td>resources_root</td>
	<td>None</td>
	<td>str</td>
	<td>Root directory to treat resources relative to; ie. if we are in
//project/main/resources and resources_root is project/main then
the resources in the .jar will be in the subdirectory 'resources'.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>exported_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Exported dependencies, ie. dependencies that other things depending on this
rule will also receive when they're compiling. This is quite important for
Java; any dependency that forms part of the public API for your classes
should be an exported dependency.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of this rule.</td>
      </tr>

      <tr>
	<td>source</td>
	<td>None</td>
	<td>int</td>
	<td>Java source level to compile sources as. Defaults to whatever's set in the config,
which itself defaults to 8.</td>
      </tr>

      <tr>
	<td>target</td>
	<td>None</td>
	<td>int</td>
	<td>Java bytecode level to target after compile. Defaults to whatever's set in the
config, which itself defaults to 8.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, this rule can only be depended on by tests.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="java_binary">java_binary</a></h3>

    <p><pre class="rule"><code>java_binary(name, main_class, deps=None, data=None, visibility=None, jvm_args=None, self_executable=False)</code></pre></p>

    <p>Compiles a .jar from a set of Java libraries.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>main_class</td>
	<td></td>
	<td>str</td>
	<td>Main class to set in the manifest.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for this rule.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of this rule.</td>
      </tr>

      <tr>
	<td>jvm_args</td>
	<td>None</td>
	<td>str</td>
	<td>Arguments to pass to the JVM in the run script.</td>
      </tr>

      <tr>
	<td>self_executable</td>
	<td>False</td>
	<td>bool</td>
	<td>True to make the jar self executable.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="java_test">java_test</a></h3>

    <p><pre class="rule"><code>java_test(name, srcs, data=None, deps=None, labels=None, visibility=None, container=False, timeout=0, flaky=False, test_outputs=None, test_package=Set in config, jvm_args)</code></pre></p>

    <p>Defines a Java test.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Java files containing the tests.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for this rule.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to attach to this test.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of this rule.</td>
      </tr>

      <tr>
	<td>flags</td>
	<td></td>
	<td>str</td>
	<td>Flags to apply to the test invocation - i.e. passed on the command line when it's run.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>True to run this test within a container (eg. Docker).</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Maximum length of time, in seconds, to allow this test to run for.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>int | bool</td>
	<td>True to mark this as flaky and automatically rerun.</td>
      </tr>

      <tr>
	<td>test_outputs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra test output files to generate from this test.</td>
      </tr>

      <tr>
	<td>test_package</td>
	<td>Set in config</td>
	<td>str</td>
	<td>Java package to scan for test classes to run.</td>
      </tr>

      <tr>
	<td>jvm_args</td>
	<td></td>
	<td>str</td>
	<td>Arguments to pass to the JVM in the run script.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="maven_jars">maven_jars</a></h3>

    <p><pre class="rule"><code>maven_jars(name, id, repository='https://repo1.maven.org/maven2', exclude=None, hashes=None, combine=False, hash=None, deps=None, visibility=None, filename=None, deps_only=False, optional=None)</code></pre></p>

    <p>Fetches a transitive set of dependencies from Maven.</p>
    <p>
Requires post build commands to be allowed for this repo.</p>
    <p>
Note that this is still fairly experimental; the interface is unlikely to change much
but it still has issues with some Maven packages.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the output rule.</td>
      </tr>

      <tr>
	<td>id</td>
	<td></td>
	<td>str</td>
	<td>Maven id of the artifact (eg. org.junit:junit:4.1.0)</td>
      </tr>

      <tr>
	<td>repository</td>
	<td>https://repo1.maven.org/maven2</td>
	<td>str</td>
	<td>Maven repo to fetch deps from.</td>
      </tr>

      <tr>
	<td>exclude</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies to ignore when fetching this one.</td>
      </tr>

      <tr>
	<td>hashes</td>
	<td>None</td>
	<td>dict</td>
	<td>Map of Maven id -> rule hash for each rule produced.</td>
      </tr>

      <tr>
	<td>combine</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, we combine all downloaded .jar files into one uberjar.</td>
      </tr>

      <tr>
	<td>hash</td>
	<td>None</td>
	<td>string</td>
	<td>Hash of final produced .jar. For brevity, implies combine=True.<br/>
	  Can optionally be a list for cases where there are jars with multiple
	  possible outputs, e.g. architecture-specific.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Labels of dependencies, as usual.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility label.</td>
      </tr>

      <tr>
	<td>filename</td>
	<td>None</td>
	<td>str</td>
	<td>Filename we attempt to download. Defaults to standard Maven name.</td>
      </tr>

      <tr>
	<td>deps_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True we fetch only dependent rules, not this one itself. Useful for some that
have a top-level target as a facade which doesn't have actual code.</td>
      </tr>

      <tr>
	<td>optional</td>
	<td>None</td>
	<td>list</td>
	<td>List of optional dependencies to fetch. By default we fetch none of them.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="maven_jar">maven_jar</a></h3>

    <p><pre class="rule"><code>maven_jar(name, id, repository='https://repo1.maven.org/maven2', hash=None, hashes=None, deps=None, visibility=None, filename=None, sources=True, licences=None, exclude_paths=None, native=False)</code></pre></p>

    <p>Fetches a single Java dependency from Maven.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the output rule.</td>
      </tr>

      <tr>
	<td>id</td>
	<td></td>
	<td>str</td>
	<td>Maven id of the artifact (eg. org.junit:junit:4.1.0)</td>
      </tr>

      <tr>
	<td>repository</td>
	<td>https://repo1.maven.org/maven2</td>
	<td>str</td>
	<td>Maven repo to fetch deps from.</td>
      </tr>

      <tr>
	<td>hash</td>
	<td>None</td>
	<td>str</td>
	<td>Hash for produced rule.</td>
      </tr>

      <tr>
	<td>hashes</td>
	<td>None</td>
	<td>list</td>
	<td>Hashes for produced rule.<br/>
	  This is generally only useful for rules with <code>native</code> set, other jars
	  will normally only have one hash.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Labels of dependencies, as usual.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility label.</td>
      </tr>

      <tr>
	<td>filename</td>
	<td>None</td>
	<td>str</td>
	<td>Filename we attempt to download. Defaults to standard Maven name.</td>
      </tr>

      <tr>
	<td>sources</td>
	<td>True</td>
	<td>bool</td>
	<td>True to download source jars as well.</td>
      </tr>

      <tr>
	<td>licences</td>
	<td>None</td>
	<td>list</td>
	<td>Licences this package is subject to.</td>
      </tr>

      <tr>
	<td>exclude_paths</td>
	<td>None</td>
	<td>list</td>
	<td>Paths to remove from the downloaded .jar.</td>
      </tr>

      <tr>
	<td>native</td>
	<td>False</td>
	<td>bool</td>
	<td>Attempt to download a native jar (i.e. add "-linux-x86_64" or "-osx-x86_64" etc to the URL).</td>
      </tr>

      </tbody>
    </table>

    <h2><a name="misc">Misc rules</a></h2>

    <p>Miscellaneous rules that aren't language-specific.</p>

    <h3><a name="genrule">genrule</a></h3>

    <p><pre class="rule"><code>genrule(name, cmd, srcs=None, out=None, outs=None, deps=None, visibility=None, arch=None, building_description=Building..., hashes=None, timeout=0, binary=False, needs_transitive_deps=False, output_is_complete=True, test_only=False, requires=None, provides=None, pre_build=None, post_build=None, tools=None)</code></pre></p>

    <p>A general build rule which allows the user to specify a command.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>cmd</td>
	<td></td>
	<td>str</td>
	<td>Command to run. It's subject to various sequence replacements:
      <ul>
        <li><code>$(location //path/to:target)</code> expands to the location of the given build rule, which
must have a single output only.</li>
        <li><code>$(locations //path/to:target)</code> expands to the locations of the outputs of the given
build rule, which can have any number of outputs.</li>
        <li><code>$(exe //path/to:target)</code> expands to a command to run the output of the given target. The rule must be marked as binary.</li>
        <li><code>$(out_location //path_to:target)</code> expands to the output of the given build rule, with
the preceding plz-out/gen etc.</li>
      </ul>
      Also a number of environment variables will be defined:
      <ul>
        <li><code>ARCH</code>: architecture we're compiling for, eg. linux_amd64</li>
        <li><code>PATH</code>: usual PATH environment variable as defined in your .plzconfig</li>
        <li><code>TMP_DIR</code>: the temporary directory you're compiling within.</li>
        <li><code>SRCS</code>: the sources of your rule</li>
        <li><code>OUTS</code>: the outputs of your rule</li>
        <li><code>PKG</code>: the path to the package containing this rule</li>
        <li><code>NAME</code>: the name of this build rule</li>
        <li><code>OUT</code>: the output of this rule. Only present when there is only one output.</li>
        <li><code>SRC</code>: the source of this rule. Only present when there is only one source.</li>
        <li><code>SRCS_&lt;suffix&gt;</code>: Present when you've defined named sources on a rule. Each group
creates one of these these variables with paths to those sources.</li>
      </ul>
    </td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list or dict</td>
	<td>Sources of this rule. Can be a list of files or rules, or a dict of names to similar
lists. In the latter case they can be accessed separately which is useful when you
have separate kinds of things in a rule.</td>
      </tr>

      <tr>
	<td>out</td>
	<td>None</td>
	<td>str</td>
	<td>A single output of this rule, as a string. Discouraged in favour of 'outs'.</td>
      </tr>

      <tr>
	<td>outs</td>
	<td>None</td>
	<td>list</td>
	<td>Outputs of this rule.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of this rule</td>
      </tr>

      <tr>
	<td>arch</td>
	<td>None</td>
	<td>str</td>
	<td>Architecture that this rule requires, e.g. &quot;linux_amd64&quot;.<br/>
          Typically this is left empty for most rules, it is only normally set for rules
          which require something specific (e.g. maybe a rkt image rule would declare
          <code>arch = 'linux_amd64'</code> because it's always Linux inside the container).</td>
      </tr>

      <tr>
	<td>building_description</td>
	<td>Building...</td>
	<td>str</td>
	<td>Description to display to the user while the rule is building.</td>
      </tr>

      <tr>
	<td>hashes</td>
	<td>None</td>
	<td>list</td>
	<td>List of hashes; if given the outputs must match one of these. They can be
optionally preceded by their method. Currently the only supported method is sha1.</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Maximum time in seconds this rule can run for before being killed.</td>
      </tr>

      <tr>
	<td>binary</td>
	<td>False</td>
	<td>bool</td>
	<td>True to mark a rule that produces a runnable output. Its output will be placed into
plz-out/bin instead of plz-out/gen and can be run with 'plz run'. Binary rules
can only have a single output.</td>
      </tr>

      <tr>
	<td>needs_transitive_deps</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, all transitive dependencies of the rule will be made
available to it when it builds (although see below...). By default
rules only get their immediate dependencies.</td>
      </tr>

      <tr>
	<td>output_is_complete</td>
	<td>True</td>
	<td>bool</td>
	<td>If this is true then the rule blocks downwards searches of transitive
dependencies by other rules (ie. it will be available to them, but not
its dependencies as well).</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True it can only be used by test rules.</td>
      </tr>

      <tr>
	<td>requires</td>
	<td>None</td>
	<td>list</td>
	<td>A list of arbitrary strings that define kinds of output that this rule might want.<br/>

See 'provides' for more detail; it's mostly useful to match up rules with multiple
kinds of output with ones that only need one of them, eg. a proto_library with
a python_library that doesn't want the C++ or Java proto outputs.<br/>

Entries in 'requires' are also implicitly labels on the rule.</td>
      </tr>

      <tr>
	<td>provides</td>
	<td>None</td>
	<td>dict</td>
	<td>A map of arbitrary strings to dependencies of the rule that provide some specific
type of thing. For example:
provides = {'py': ':python_rule', 'go': ':go_rule'},
A Python rule would have requires = ['py'] and so if it depended on a rule like
this it would pick up a dependency on :python_rule instead. See the proto rules
for an example of where this is useful.<br/>

Note that the keys of provides and entries in requires are arbitrary and
have no effect until a matched pair meet one another.</td>
      </tr>

      <tr>
	<td>pre_build</td>
	<td>None</td>
	<td>function</td>
	<td>A function to be executed immediately before the rule builds. It receives one
argument, the name of the building rule. This is mostly useful to interrogate
the metadata of dependent rules which isn't generally available at parse time;
see the get_labels function for a motivating example.</td>
      </tr>

      <tr>
	<td>post_build</td>
	<td>None</td>
	<td>function</td>
	<td>A function to be executed immediately after the rule builds. It receives two
arguments, the rule name and its command line output.<br/>

This is significantly more useful than the pre_build function, it can be used
to dynamically create new rules based on the output of another.</td>
      </tr>

      <tr>
	<td>tools</td>
	<td>None</td>
	<td>list</td>
	<td>Tools used to build this rule; similar to srcs but are not copied to the temporary
          build directory. Should be accessed via $(exe //path/to:tool) or similar.<br/>
          Entries that are not build labels are assumed to be system-level commands and
          resolved within the path given in the config file (note that the value of $PATH
          in the outside environment is not propagated to the build rule).</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="gentest">gentest</a></h3>

    <p><pre class="rule"><code>gentest(name, test_cmd, labels=None, cmd=None, srcs=None, outs=None, deps=None, tools=None, data=None, visibility=None, timeout=0, needs_transitive_deps=False, flaky=False, no_test_output=False, output_is_complete=True, requires=None, container=False)</code></pre></p>

    <p>A rule which creates a test with an arbitrary command.</p>
    <p>
The command must return zero on success and nonzero on failure. Test results are written
to test.results (or not if no_test_output is True).</p>
    <p>Most arguments are similar to genrule() so we cover them in less detail here.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>test_cmd</td>
	<td></td>
	<td>str</td>
	<td>Command to run for the test.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to apply to this test.</td>
      </tr>

      <tr>
	<td>cmd</td>
	<td>None</td>
	<td>str</td>
	<td>Command to run to build the test.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list or dict</td>
	<td>Source files for this rule.</td>
      </tr>

      <tr>
	<td>outs</td>
	<td>None</td>
	<td>list</td>
	<td>Output files of this rule.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>tools</td>
	<td>None</td>
	<td>list</td>
	<td>Tools used to build this rule; similar to srcs but are not copied to the temporary
build directory. Should be accessed via <code>$(exe //path/to:tool)</code> or similar.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for the test.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of this rule.</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Length of time in seconds to allow the test to run for before killing it.</td>
      </tr>

      <tr>
	<td>needs_transitive_deps</td>
	<td>False</td>
	<td>bool</td>
	<td>True if building the rule requires all transitive dependencies to
be made available.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>bool | int</td>
	<td>If true the test will be marked as flaky and automatically retried.</td>
      </tr>

      <tr>
	<td>no_test_output</td>
	<td>False</td>
	<td>bool</td>
	<td>If true the test is not expected to write any output results, it's only
judged on its return value.</td>
      </tr>

      <tr>
	<td>output_is_complete</td>
	<td>True</td>
	<td>bool</td>
	<td>If this is true then the rule blocks downwards searches of transitive
dependencies by other rules.</td>
      </tr>

      <tr>
	<td>requires</td>
	<td>None</td>
	<td>list</td>
	<td>Kinds of output from other rules that this one requires.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>If true the test is run in a container (eg. Docker).</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="export_file">export_file</a></h3>

    <p><pre class="rule"><code>export_file(name, src, visibility=None, binary=False, test_only=False)</code></pre></p>

    <p>Essentially a single-file alias for filegroup.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>src</td>
	<td></td>
	<td>str</td>
	<td>Source file for the rule</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration</td>
      </tr>

      <tr>
	<td>binary</td>
	<td>False</td>
	<td>bool</td>
	<td>True to mark the rule outputs as binary</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If true the exported file can only be used by test targets.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="filegroup">filegroup</a></h3>

    <p><pre class="rule"><code>filegroup(name, srcs=None, deps=None, exported_deps=None, visibility=None, labels=None, binary=False, output_is_complete=True, requires=None, provides=None, link=True, test_only=False)</code></pre></p>

    <p>Defines a collection of files which other rules can depend on.</p>
    <p>
Sources can be omitted entirely in which case it acts simply as a rule to collect other rules,
which is often more handy than you might think.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>Source files for the rule.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of the rule.</td>
      </tr>

      <tr>
	<td>exported_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies that will become visible to any rules that depend on this rule.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to apply to this rule</td>
      </tr>

      <tr>
	<td>binary</td>
	<td>False</td>
	<td>bool</td>
	<td>True to mark the rule outputs as binary</td>
      </tr>

      <tr>
	<td>output_is_complete</td>
	<td>True</td>
	<td>bool</td>
	<td>If this is true then the rule blocks downwards searches of transitive
dependencies by other rules.</td>
      </tr>

      <tr>
	<td>requires</td>
	<td>None</td>
	<td>list</td>
	<td>Kinds of output from other rules that this one requires.</td>
      </tr>

      <tr>
	<td>provides</td>
	<td>None</td>
	<td>dict</td>
	<td>Kinds of output that this provides for other rules (see genrule() for a more
in-depth discussion of this).</td>
      </tr>

      <tr>
	<td>link</td>
	<td>True</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If true the exported file can only be used by test targets.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="system_library">system_library</a></h3>

    <p><pre class="rule"><code>system_library(name, srcs, deps=None, hashes=None, visibility=None, test_only=False)</code></pre></p>

    <p>Defines a rule to collect some dependencies from outside the build tree.</p>
    <p>
This is essentially the same as a filegroup; it will simply copy files from the system
into the build tree, you must add additional rules if compilation is necessary.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>hashes</td>
	<td>None</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of the rule.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If true the rule is only visible to test targets.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="remote_file">remote_file</a></h3>

    <p><pre class="rule"><code>remote_file(name, url, hashes=None, out=None, binary=False, visibility=None, test_only=False)</code></pre></p>

    <p>Defines a rule to fetch a file over HTTP(S).</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>url</td>
	<td></td>
	<td>str</td>
	<td>URL to fetch</td>
      </tr>

      <tr>
	<td>hashes</td>
	<td>None</td>
	<td>list</td>
	<td>List of hashes; the output must match at least one of these.</td>
      </tr>

      <tr>
	<td>out</td>
	<td>None</td>
	<td>str</td>
	<td>Output name of the file. Chosen automatically if not given.</td>
      </tr>

      <tr>
	<td>binary</td>
	<td>False</td>
	<td>bool</td>
	<td>True to mark the output as binary and runnable.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of the rule.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If true the rule is only visible to test targets.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="github_file">github_file</a></h3>

    <p><pre class="rule"><code>github_file(name, repo, file, revision=master, hash=None, visibility=None, test_only=False)</code></pre></p>

    <p>Defines a rule to fetch a file from Github.</p>
    <p>
This is just a convenience wrapper around remote_file but is somewhat clearer to write.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>repo</td>
	<td></td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>file</td>
	<td></td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>revision</td>
	<td>master</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>hash</td>
	<td>None</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of the rule.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If true the rule is only visible to test targets.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="fpm_package">fpm_package</a></h3>

    <p><pre class="rule"><code>fpm_package(name, files, version, package_type, links=None, package_name=None, options, srcs=None, deps=None, visibility=None, labels=None)</code></pre></p>

    <p>Defines a rule to build a package using fpm.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Rule name</td>
      </tr>

      <tr>
	<td>files</td>
	<td></td>
	<td>dict</td>
	<td>Dict of locations -> files to include, for example:
{
'/usr/bin/plz': '//src:please',
'/usr/share/plz/junit_runner': '//src/build/java:junit_runner',
'/usr/share/plz/some_file': 'some_file',  # file in this package
}</td>
      </tr>

      <tr>
	<td>version</td>
	<td></td>
	<td>str</td>
	<td>Version of the package.</td>
      </tr>

      <tr>
	<td>package_type</td>
	<td></td>
	<td>str</td>
	<td>Type of package to build (deb, rpm, etc)</td>
      </tr>

      <tr>
	<td>links</td>
	<td>None</td>
	<td>dict</td>
	<td>Dict of locations -> file to link to, for example:
{
'/usr/bin/plz': '/opt/please',
}</td>
      </tr>

      <tr>
	<td>package_name</td>
	<td>None</td>
	<td>str</td>
	<td>Name of package. Defaults to rule name.</td>
      </tr>

      <tr>
	<td>options</td>
	<td></td>
	<td>str</td>
	<td>Extra options to pass to fpm.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra sources (it's not necessary to mention entries in 'files' here)</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels associated with this rule.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="fpm_deb">fpm_deb</a></h3>

    <p><pre class="rule"><code>fpm_deb(name, files, version, links=None, package_name=None, options, srcs=None, deps=None, visibility=None, labels=None)</code></pre></p>

    <p>Convenience wrapper around fpm_package that always builds a .deb package.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Rule name</td>
      </tr>

      <tr>
	<td>files</td>
	<td></td>
	<td>dict</td>
	<td>Dict of locations -> files to include, for example:
{
'/usr/bin/plz': '//src:please',
'/usr/share/plz/junit_runner': '//src/build/java:junit_runner',
'/usr/share/plz/some_file': 'some_file',  # file in this package
}</td>
      </tr>

      <tr>
	<td>version</td>
	<td></td>
	<td>str</td>
	<td>Version of the package.</td>
      </tr>

      <tr>
	<td>links</td>
	<td>None</td>
	<td>dict</td>
	<td>Dict of locations -> file to link to, for example:
{
'/usr/bin/plz': '/opt/please',
}</td>
      </tr>

      <tr>
	<td>package_name</td>
	<td>None</td>
	<td>str</td>
	<td>Name of package. Defaults to rule name.</td>
      </tr>

      <tr>
	<td>options</td>
	<td></td>
	<td>str</td>
	<td>Extra options to pass to fpm.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra sources (it's not necessary to mention entries in 'files' here)</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels associated with this rule.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="tarball">tarball</a></h3>

    <p><pre class="rule"><code>tarball(name, srcs, out=None, deps=None, subdir=None, compression=gzip, visibility=None, labels=None)</code></pre></p>

    <p>Defines a rule to create a tarball containing outputs of other rules.</p>
    <p>
    File mode and ownership are preserved. However, the atime and mtime of all files will be set to 1 Jan 1970 00:00:00.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Rule name</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Source files to include in the tarball</td>
      </tr>

      <tr>
	<td>out</td>
	<td>None</td>
	<td>str</td>
	<td>Name of output tarball (defaults to `name`.tar.gz, but see below re compression)</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>subdir</td>
	<td>None</td>
	<td>str</td>
	<td>Subdirectory to create in (defaults to 'name')</td>
      </tr>

      <tr>
	<td>compression</td>
	<td>gzip</td>
	<td>str</td>
	<td>Kind of compression to use. Either one of {gzip, bzip2, xz, lzma}
to filter through known tar methods, an explicit flag, or None for
no compression.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels associated with this rule.</td>
      </tr>

      </tbody>
    </table>

    <h2><a name="proto">Proto rules</a></h2>

    <p>Build rules for compiling protocol buffers & gRPC service stubs.</p>
    <p>
Note that these are some of the most complex of our built-in build rules,
because of their cross-language nature. Each proto_library rule declares a set of
sub-rules to run protoc & the appropriate java_library, go_library rules etc. Users
shouldn't worry about those sub-rules and just declare a dependency directly on
the proto_library rule to get its appropriate outputs.</p>

    <h3><a name="proto_library">proto_library</a></h3>

    <p><pre class="rule"><code>proto_library(name, srcs, plugins=None, deps=None, visibility=None, labels=None, python_deps=None, cc_deps=None, java_deps=None, go_deps=None, protoc_version=Set in config, languages=None)</code></pre></p>

    <p>Compile a .proto file to generated code for various languages.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Input .proto files.</td>
      </tr>

      <tr>
	<td>plugins</td>
	<td>None</td>
	<td>dict</td>
	<td>Plugins to invoke for code generation.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification for the rule.<br/>

labels(list): List of labels to apply to this rule.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>python_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the python_library rules</td>
      </tr>

      <tr>
	<td>cc_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the cc_library rules</td>
      </tr>

      <tr>
	<td>java_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the java_library rules</td>
      </tr>

      <tr>
	<td>go_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the go_library rules</td>
      </tr>

      <tr>
	<td>protoc_version</td>
	<td>Set in config</td>
	<td>str</td>
	<td>Version of protoc compiler, used to invalidate build rules when it changes.</td>
      </tr>

      <tr>
	<td>languages</td>
	<td>None</td>
	<td>list</td>
	<td>List of languages to generate rules for, chosen from the set {cc, py, go, java}.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="grpc_library">grpc_library</a></h3>

    <p><pre class="rule"><code>grpc_library(name, srcs, deps=None, visibility=None, languages=None, python_deps=None, java_deps=None, go_deps=None)</code></pre></p>

    <p>Defines a rule for a grpc library.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Input .proto files.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies (other proto_library rules)</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification for the rule.</td>
      </tr>

      <tr>
	<td>languages</td>
	<td>None</td>
	<td>list</td>
	<td>List of languages to generate rules for, chosen from the set {cc, py, go, java}.<br/>

At present this will not create any service definitions for C++, but 'cc' is
still accepted for forwards compatibility.</td>
      </tr>

      <tr>
	<td>python_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the python_library rules</td>
      </tr>

      <tr>
	<td>java_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the java_library rules</td>
      </tr>

      <tr>
	<td>go_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the go_library rules</td>
      </tr>

      <tr>
	<td>cc_deps</td>
	<td>None</td>
	<td>list</td>
	<td>Additional deps to add to the cc_library rules</td>
      </tr>

      </tbody>
    </table>

    <h2><a name="python">Python rules</a></h2>

    <p>Rules to build Python code.</p>
    <p>
The output artifacts for Python rules are .pex files (see https://github.com/pantsbuild/pex).</p>
    <p>Pex is a rather nice system for combining Python code and all needed dependencies
(excluding the actual interpreter and possibly some system level bits) into a single file.</p>
    <p>
The process of compiling pex files can be a little slow when including many large files, as
often happens when one's binary includes large compiled dependencies (eg. numpy...). Hence
we have a fairly elaborate optimisation whereby each python_library rule builds a little
zipfile containing just its sources, and all of those are combined at the end to produce
the final .pex. This builds at roughly the same pace for a clean build of a single target,
but is drastically faster for building many targets with similar dependencies or rebuilding
a target which has only had small changes.</p>

    <h3><a name="python_library">python_library</a></h3>

    <p><pre class="rule"><code>python_library(name, srcs=None, resources=None, deps=None, visibility=None, test_only=False, zip_safe=True, labels=None, interpreter=None)</code></pre></p>

    <p>Generates a Python library target, which collects Python files for use by dependent rules.</p>
    <p>
Note that each python_library performs some pre-zipping of its inputs before they're combined
in a python_binary or python_test. Hence while it's of course not required that all dependencies
of those rules are python_library rules, it's often a good idea to wrap any large dependencies
in one to improve incrementality (not necessary for pip_library, of course).</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td>None</td>
	<td>list</td>
	<td>Python source files for this rule.</td>
      </tr>

      <tr>
	<td>resources</td>
	<td>None</td>
	<td>list</td>
	<td>Non-Python files that this rule collects which will be included in the final .pex.<br/>

The distinction between this and srcs is fairly arbitrary and historical, but
semantically quite nice and parallels python_test.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification.</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td>bool</td>
	<td>If True, can only be depended on by tests.</td>
      </tr>

      <tr>
	<td>zip_safe</td>
	<td>True</td>
	<td>bool</td>
	<td>Should be set to False if this library can't be safely run inside a .pex
(the most obvious reason not is when it contains .so modules).<br/>

See python_binary for more information.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to apply to this rule.</td>
      </tr>

      <tr>
	<td>interpreter</td>
	<td>Set in config</td>
	<td>str</td>
	<td>The Python interpreter to use. Defaults to the config setting
which is normally just 'python', but could be 'python3' or
'pypy' or whatever.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="python_binary">python_binary</a></h3>

    <p><pre class="rule"><code>python_binary(name, main, out=None, deps=None, visibility=None, zip_safe=None, interpreter=Set in config)</code></pre></p>

    <p>Generates a Python binary target.</p>
    <p>
This compiles all source files together into a single .pex file which can
be easily copied or deployed. The construction of the .pex is done in parts
by the dependent python_library rules, and this rule simply builds the
metadata for it and concatenates them all together.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>main</td>
	<td></td>
	<td>str</td>
	<td>Python file which is the entry point and __main__ module.</td>
      </tr>

      <tr>
	<td>resources</td>
	<td></td>
	<td>list</td>
	<td>Non-Python files that this rule collects which will be included in the final .pex.</td>
      </tr>

      <tr>
	<td>out</td>
	<td>None</td>
	<td>str</td>
	<td>Name of the output file. Default to name + .pex</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification.</td>
      </tr>

      <tr>
	<td>zip_safe</td>
	<td>None</td>
	<td>bool</td>
	<td>Allows overriding whether the output is marked zip safe or not.<br/>

If set to explicitly True or False, the output will be marked
appropriately; by default it will be safe unless any of the
transitive dependencies are themselves marked as not zip-safe.</td>
      </tr>

      <tr>
	<td>interpreter</td>
	<td>Set in config</td>
	<td>str</td>
	<td>The Python interpreter to use. Defaults to the config setting
which is normally just 'python', but could be 'python3' or
'pypy' or whatever.</td>
      </tr>

      <tr>
	<td>shebang</td>
	<td></td>
	<td>str</td>
	<td>The exact shebang (minus the leading #!) to apply to the generated .pex.<br/>
	  By default pex will choose something appropriate for the current interpreter,
	  but this allows overriding it if you need something different.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="python_test">python_test</a></h3>

    <p><pre class="rule"><code>python_test(name, srcs, data=None, resources=None, deps=None, labels=None, visibility=None, container=False, timeout=0, flaky=False, test_outputs=None, zip_safe=None, interpreter=Set in config)</code></pre></p>

    <p>Generates a Python test target.</p>
    <p>
This works very similarly to python_binary; it is also a single .pex file
which is run to execute the tests. The tests are run via unittest.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule.</td>
      </tr>

      <tr>
	<td>srcs</td>
	<td></td>
	<td>list</td>
	<td>Source files for this test.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data files for the test.</td>
      </tr>

      <tr>
	<td>resources</td>
	<td>None</td>
	<td>list</td>
	<td>Non-Python files to be included in the pex. Note that the distinction
vs. srcs is important here; srcs are passed to unittest for it to run
and it may or may not be happy if given non-Python files.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels for this rule.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility specification.</td>
      </tr>

      <tr>
	<td>flags</td>
	<td></td>
	<td>str</td>
	<td>Flags to apply to the test invocation - i.e. passed on the command line when it's run.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>If True, the test will be run in a container (eg. Docker).</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Maximum time this test is allowed to run for, in seconds.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>int | bool</td>
	<td>True to mark this test as flaky, or an integer for a number of reruns.</td>
      </tr>

      <tr>
	<td>test_outputs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra test output files to generate from this test.</td>
      </tr>

      <tr>
	<td>zip_safe</td>
	<td>None</td>
	<td>bool</td>
	<td>Allows overriding whether the output is marked zip safe or not.<br/>

If set to explicitly True or False, the output will be marked
appropriately; by default it will be safe unless any of the
transitive dependencies are themselves marked as not zip-safe.</td>
      </tr>

      <tr>
	<td>interpreter</td>
	<td>Set in config</td>
	<td>str</td>
	<td>The Python interpreter to use. Defaults to the config setting
which is normally just 'python', but could be 'python3' or
'pypy' or whatever.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="pip_library">pip_library</a></h3>

    <p><pre class="rule"><code>pip_library(name, version, hashes=None, package_name=None, outs=None, test_only=False, env=None, deps=None, post_install_commands=None, install_subdirectory=False, repo=None, use_pypi=None, patch=None, visibility=None, zip_safe=True, licences=None)</code></pre></p>

    <p>Provides a build rule for third-party dependencies to be installed by pip.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the build rule.</td>
      </tr>

      <tr>
	<td>version</td>
	<td></td>
	<td>str</td>
	<td>Specific version of the package to install.</td>
      </tr>

      <tr>
	<td>hashes</td>
	<td>None</td>
	<td>list</td>
	<td>List of acceptable hashes for this target.</td>
      </tr>

      <tr>
	<td>package_name</td>
	<td>None</td>
	<td>str</td>
	<td>Name of the pip package to install. Defaults to the same as 'name'.</td>
      </tr>

      <tr>
	<td>outs</td>
	<td>None</td>
	<td>list</td>
	<td>List of output files / directories. Defaults to [name].</td>
      </tr>

      <tr>
	<td>test_only</td>
	<td>False</td>
	<td></td>
	<td></td>
      </tr>

      <tr>
	<td>env</td>
	<td>None</td>
	<td>dict</td>
	<td>Environment variables to provide during pip install, as a dict (or similar).</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>List of rules this library depends on.</td>
      </tr>

      <tr>
	<td>post_install_commands</td>
	<td>None</td>
	<td>list</td>
	<td>Commands run after pip install has completed.</td>
      </tr>

      <tr>
	<td>install_subdirectory</td>
	<td>False</td>
	<td>bool</td>
	<td>Forces the package to install into a subdirectory with this name.</td>
      </tr>

      <tr>
	<td>repo</td>
	<td>None</td>
	<td>str</td>
	<td>Allows specifying a custom repo to fetch from.</td>
      </tr>

      <tr>
	<td>use_pypi</td>
	<td>None</td>
	<td>bool</td>
	<td>If True, will check PyPI as well for packages.</td>
      </tr>

      <tr>
	<td>patch</td>
	<td>None</td>
	<td>str</td>
	<td>A patch file to be applied after install.</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration for this rule.</td>
      </tr>

      <tr>
	<td>zip_safe</td>
	<td>True</td>
	<td>bool</td>
	<td>Flag to indicate whether a pex including this rule will be zip-safe.</td>
      </tr>

      <tr>
	<td>licences</td>
	<td>None</td>
	<td>list</td>
	<td>Licences this rule is subject to. Default attempts to detect from package metadata.</td>
      </tr>

      </tbody>
    </table>

    <h2><a name="sh">Sh rules</a></h2>

    <p>Rules to 'build' shell scripts.</p>
    <p>
Note that these do pretty much nothing beyond collecting the files. In future we might
implement something more advanced (ala .sar files or whatever).</p>

    <h3><a name="sh_library">sh_library</a></h3>

    <p><pre class="rule"><code>sh_library(name, src, deps=None, visibility=None, link=True, labels=None)</code></pre></p>

    <p>Generates a shell script binary, essentially just the given source.</p>
    <p>
Note that these are individually executable so can only have one source file each.</p>
    <p>This is a bit tedious and would be nice to improve sometime.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>src</td>
	<td></td>
	<td>str</td>
	<td>Source file for the rule</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of the rule.</td>
      </tr>

      <tr>
	<td>link</td>
	<td>True</td>
	<td>bool</td>
	<td>Deprecated, has no effect.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to apply to this test.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="sh_binary">sh_binary</a></h3>

    <p><pre class="rule"><code>sh_binary(name, main, deps=None, visibility=None, link=True, labels=None)</code></pre></p>

    <p>Generates a shell binary, essentially just the shell script itself.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>main</td>
	<td></td>
	<td>str</td>
	<td>Main script file.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of the rule.</td>
      </tr>

      <tr>
	<td>link</td>
	<td>True</td>
	<td>bool</td>
	<td>If True, outputs will be linked in plz-out; if False they'll be copied.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to apply to this test.</td>
      </tr>

      </tbody>
    </table>

    <h3><a name="sh_test">sh_test</a></h3>

    <p><pre class="rule"><code>sh_test(name, src=None, args=None, labels=None, data=None, deps=None, visibility=None, flaky=False, test_outputs=None, timeout=0, container=False)</code></pre></p>

    <p>Generates a shell test. Note that these aren't packaged in a useful way.</p>

    <table>
      <thead>
      <tr>
	<th>Argument</th>
	<th>Default</th>
	<th>Type</th>
	<th></th>
      </tr>
      </thead>
      <tbody>

      <tr>
	<td>name</td>
	<td></td>
	<td>str</td>
	<td>Name of the rule</td>
      </tr>

      <tr>
	<td>src</td>
	<td>None</td>
	<td>str</td>
	<td>Test script file.</td>
      </tr>

      <tr>
	<td>args</td>
	<td>None</td>
	<td>list</td>
	<td>Arguments that will be passed to this test when run.<br/>
      Deprecated in favour of <code>flags</code>.</td>
      </tr>

      <tr>
	<td>flags</td>
	<td></td>
	<td>str</td>
	<td>Flags to apply to the test invocation - i.e. passed on the command line when it's run.</td>
      </tr>

      <tr>
	<td>labels</td>
	<td>None</td>
	<td>list</td>
	<td>Labels to apply to this test.</td>
      </tr>

      <tr>
	<td>data</td>
	<td>None</td>
	<td>list</td>
	<td>Runtime data for the test.</td>
      </tr>

      <tr>
	<td>deps</td>
	<td>None</td>
	<td>list</td>
	<td>Dependencies of this rule</td>
      </tr>

      <tr>
	<td>visibility</td>
	<td>None</td>
	<td>list</td>
	<td>Visibility declaration of the rule.</td>
      </tr>

      <tr>
	<td>flaky</td>
	<td></td>
	<td>int | bool</td>
	<td>True to mark this as flaky and automatically rerun.</td>
      </tr>

      <tr>
	<td>test_outputs</td>
	<td>None</td>
	<td>list</td>
	<td>Extra test output files to generate from this test.</td>
      </tr>

      <tr>
	<td>timeout</td>
	<td></td>
	<td>int</td>
	<td>Maximum length of time, in seconds, to allow this test to run for.</td>
      </tr>

      <tr>
	<td>container</td>
	<td>False</td>
	<td>bool | dict</td>
	<td>True to run this test within a container (eg. Docker).</td>
      </tr>

      </tbody>
    </table>
