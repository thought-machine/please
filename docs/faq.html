<!DOCTYPE html>
<html>
  <head>
    <title>Please FAQ</title>
    <link rel="stylesheet" type="text/css" href="skeleton.css">
  </head>
  <body>
    <!-- HEADER -->

    <h1>FAQ</h1>

    <h3>Can I run it on my computer?</h3>

    <p>If you're running Linux or OSX, definitely; we actively support both those platforms.<br/>
      We primarily test on Ubuntu but other distros should work fine too.</p>

    <p>It can self-host and passes all the core tests on FreeBSD. A little more work is required
      to set everything up; it'd be nice to streamline this at some point. Notable issues include:
      <ul>
        <li>The RPC cache is unavailable because gRPC does not compile on FreeBSD yet.
          See <a href="https://github.com/grpc/grpc/issues/1035">the upstream issue</a>
          for more details.<br/>
          This should have no notable downsides for clients other than them not being able
          to communicate with such a cache.</li>
        <li>You'll need Bash installed for the bootstrap script to run.</li>
        <li><code>go tool link</code> appears to invoke <code>gcc</code> instead of <code>cc</code>,
          so you'll either need it installed or to provide a symlink.</li>
        <li>The ports install of Python doesn't provide some of the symlinks we'd like
          (specifically it only has <code>python2.7</code> and we'd like <code>python2</code> and
          <code>python</code>).</li>
      </ul>
    </p>

    <p>Windows is unfortunately not supported natively, since it's just too different from the
      Unix environment Please is designed for. It might well be possible to make it work using
      Cygwin or MinGW / MSYS though. We aren't doing this work ourselves because we don't
      have any Windows machines at work, but we're happy to accept PRs in that direction.</p>


    <h3>What's the licence?</h3>

    <p>TODO(all): decide! I suggest Apache-2.0 which both Buck and Bazel use.</p>


    <h3>Why use Please instead of go build / Maven / Gradle?</h3>

    <p>Cross-language support is a big advantage; we have four main languages in use at Thought Machine
      (Javascript, Python, Java and Go) plus several smaller pieces (some C++ and Thrax grammars) and
      having to invoke different compilers and/or test tools for each one would be extremely tiresome.</p>

    <p>Initially we tried Gradle for a while, since the oldest parts of our codebase are Java and we
      strongly preferred its file format over Ant and Maven. Extending it to other languages didn't
      look easy and even for a single-language project, Please is considerably faster.</p>

    <p>Please can also integrate many different kinds of build steps; for example a code generation
      step using <code>go generate</code> or <code>protoc</code> can be invoked dynamically without
      having to check the resulting code into the repository.</p>


    <h3>Why use Please instead of Bazel, Buck or Pants?</h3>

    <p>All four of these systems are quite closely related in the scheme of things, being inspired by
      (or in Bazel's case, a direct open sourcing of) Google's Blaze.</p>

    <p>Several of us had worked at Google and used Blaze extensively there; we were excited about it being
      open sourced as Bazel but by then we were already using Please internally. It's a great system but
      we have slightly different goals, specifically we're aiming Please at being lighter weight and
      pushing the boundaries of what can be done within the BUILD language. Since Please is written in
      Go there's no runtime dependency on the JVM (unless you have Java rules in your repo, of course).
    </p>

    <p>We actually used Buck for some months internally before deciding to write Please and before it
      was capable of building our repo. We preferred it to other options available, but again we're
      focused on different goals; Please is easier to extend to new languages, has a bunch of features
      that we specifically wanted (e.g. test containerisation) and again doesn't require a JVM.<br/>
      Please also has a stronger focus on correctness; we made some mistakes in writing our own rules at
      first which resulted in some flaky build failures and/or bad performance. These kinds of mistakes
      should be much harder to make with Please.</p>

    <p>We're least familiar with Pants; one of our developers briefly tried it and while we liked
      many aspects we thought Buck would be a closer fit for what we needed. Again, we feel Please
      is easier to extend to other languages due to more powerful BUILD language primitives.</p>


    <h3>What inspired the design of Please?</h3>

    <p>Originally Blaze, since a number of us had used it at Google. More recently we'd used Buck
      internally so many things superficially resemble that for compatibility reasons
      (e.g. <code>python_binary</code> instead of <code>py_binary</code> etc).</p>

    <p>Some of the advanced features are based on things we would have liked to do with Blaze, for example
      being able to defer creation of some build rules until they actually need to be built. This is
      only really of interest for spectacularly large trees of targets or especially esoteric use
      cases though.</p>

    <p>Mostly, of course, it was inspired by our fearless leader Paul, specifically the point when
      he told us "you absolutely cannot write your own build system". After that it was
      really inevitable...</p>


    <h3>Why is it so fast?</h3>

    <p>Firstly, all the rules explicitly declare their dependencies, so Please can aggressively
      parallelise build rules wherever possible. It can also cche & reuse previous outputs when
      they haven't changed, and it hashes all input files to make sure it's correct.</p>

    <p>Also BUILD files encourage you to break projects into smaller components, which can then
      be compiled in parallel. It's still possible to define a project with a single BUILD file
      in the traditional Java way that one would use in Gradle etc, and this works fine for
      smaller projects, but for larger ones parallelising the compilation can be a big advantage.</p>

    <p>There are no separate steps inside Please; parsing BUILD files, building targets and running
      tests can all happen simultaneously, so there's no down time waiting for the last thing to
      compile before the tests begin. The parsing process is also very fast due to having an
      in-process PyPy interpreter.</p>

    <p>Finally, the rules themselves are optimised in various ways; for example, the construction of
      the final .jar from a <code>java_binary</code> is an efficient concatenation of other .jar
      files without any recompression. Similarly the output .pex from a <code>python_binary</code>
      is built up piecemeal throughout the <code>python_library</code> rules and assembled at the end
      so we don't have to recompress an entire zip file every time you change one .py file.</p>


    <h3>How do you parse the BUILD files? What format are they?</h3>

    <p>The BUILD files are a (slightly) restricted dialect of Python. Please uses
      <a href="http://pypy.org">PyPy</a> to parse them which is done in-process,
      allowing a tight integration and a rich API with things like callbacks.<br/>
      Possibly surprisingly we're using PyPy more for its straightforward embedding API than
      any performance benefit over CPython, and swapping the implementation would be far
      too much work to perform benchmarks between the two.</p>

    <p>The restrictions on the format are essentially that <code>import</code> and <code>print</code>
      are banned, and a number of the normal builtins are not available.<br/>
      A small handful of <code>os</code> members are available directly as globals
      (named <code>join_path</code>, <code>split_path</code>, <code>splitext</code>,
      <code>basename</code> and <code>dirname</code>) since they're extremely relevant to
      the kinds of things rules typically do.</p>

    <p>One down side to this is that the BUILD files are a little hard to automatically edit or
      update compared to a data format like XML, Yaml or JSON. We think this is worth the tradeoff
      for giving the developer more power and (in our opinion) a significantly nicer format.</p>


    <h3>How does Please build itself? Do I need Please to build Please?</h3>

    <p>Please bootstraps itself using <code>go build</code> to build a temporary version of itself,
      which is then used to rebuild itself using its own BUILD rules. This requires a little
      duplication between the initial bootstrap script and the BUILD rules but obviously we
      can't rely on anyone building it already having a version of it installed.</p>

    <p>Fortunately the process is pretty fast since Go is fast to compile.</p>


    <h3>Why write it in Go?</h3>

    <p>We excluded most other languages that any of us were familiar with through a process
      of elimination; JVM languages were ruled out from a concern about startup overhead,
      we were concerned about Python's threading performance for an inherently parallel system
      and felt C++ was too fiddly and lacked a strong standard library. Rust was still pre-1.0
      at the time (although that didn't take long, as it turned out) so we felt it was a bit
      early to leap into that.</p>

    <p>It also turned out to be a really useful way of learning the language; the project is
      about the right size to explore it properly and sufficiently self-contained not to
      affect other parts of our repo until we were sure Go was a language we wanted to do more of.</p>

    <p>We're very happy with the results; the performance of native binaries is excellent,
      the language was easy to become productive with and has great support for all the things
      we needed to do with it. Our early concerns (e.g. the classic "no generics!")
      turned out to be a lot less problematic than we expected.</p>

    <p>An alternative explanation is that the original high-level design meeting for Please was
      an impromptu discussion in a pub one Friday evening, where we thought it would be a neat
      language to try despite none of us having any real experience with it.</p>


    <h3>Is this the primary repo, or do you have a secret internal version too?</h3>

    <p>This is the only repository; all development is done here. Initially we had an internally
      hosted repo but transferred the project to Github in preparation for open sourcing it.

    <p>We've got some build rules in our internal repo that aren't built into Please yet.
      We intend to move them into this repo as we can, but the ones left aren't easy to genericise
      for various reasons.</p>


    <h3>How does the versioning scheme work? What are the compatibility guarantees?</h3>

    <p>At the moment we're not quite doing <a href="http://semver.org">semver</a> because
      we're one level down (essentially all versions have a preceding "1." on the front from
      how they'd have us work). We might change to that soon to make it a bit easier to know
      what to expect.</p>

    <p>In a somewhat similar way to the Go project, we consider some things to have stronger
      compatibility guarantees than others. Specifically the command-line interface and flags,
      the config file format and the BUILD file format and builtins are essentially the API
      of the project and so we take significantly more care about compatibility around those.<br/>
      The interface to the various sub-tools invoked by Please we consider an implementation
      detail and those might change more aggressively (although in practice they rarely do).</p>

    <p>Things whose behaviour is not explicitly specified might change with less notice,
      because of course you shouldn't have been relying on it anyway. This includes the exact
      hash generation method - if it becomes necessary to change that for a bugfix it may force
      apparently unnecessary rebuilds after an update. We try to avoid that as much as possible
      since it's aggravating (for us too!) but since it doesn't affect eventual correctness
      it can change in minor releases.</p>


    <h3>What do the colours in the console output mean?</h3>

    <p>They change based on the type of rule that's being built:</p>

    <ul>
      <li>Yellow: Go</li>
      <li>Green: Python</li>
      <li>Red: Java</li>
      <li>Blue: Javascript</li>
      <li>Cyan: Parsing a BUILD file</li>
      <li>Magenta: Third party dependencies</li>
      <li>White: Anything else.</li>
    </ul>

    <p>Libraries are normal weight, binaries (including tests) are bold.</p>

    <p>There is absolutely no significance to the choice of colours beyond arbitrary choice
      when that code was originally written.</p>


    <h3>Why's it called Please?</h3>

    <p>Because we liked the idea of sounding polite when typing "plz build", "plz test", etc.<br/>
      Also we chose the domain name before almost anything else (priorities!).</p>

  </body>
</html>
