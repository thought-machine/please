""" Rules to build Go code.

Go has a strong built-in concept of packages so it's probably a good idea to match Please
rules to Go packages.
"""
def go_toolchain(name:str, url:str|dict = '', version:str = '', hashes:list = [], visibility:list = ["PUBLIC"]):
    """
    Downloads Go and exposes :<name>|go and :<name>|gofmt as entry points. To use this rule add the
    following to your .plzconfig:

    [go]
    GoTool = //.../<name>|go

    Args:
      name (str): Name of the rule.
      url (str | dict): The URL used to download Go. Can be a single string or a dictionary mapping
                        GOOS-GOARCH to URLs i.e. linux-amd64: 'https://...'. Either provide url or version, but not both.
      version (str): The version of Go to download. Go will be downloaded from https://golang.org/dl/...
                     and the rule will use the current platforms GOOS and GOARCH setting. Either provide url or version,
                     but not both.
      hashes (list): A list of possible hashes for the downloaded archive. Optional.
      visibility (list): Visibility specification. Defaults to public.
    """
    if url and version:
        raise ParseError("Either version or url should be provided but not both")

    if version:
        sdk_url = f'https://golang.org/dl/go{version}.{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}.tar.gz'
    else:
        sdk_url = url if isinstance(url, str) else url[f'{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}']

    download = remote_file(
        name = name,
        _tag = 'download',
        url = sdk_url,
        hashes = hashes,
    )

    cmd = 'tar -xf $SRCS && mv go $OUT && chmod +x $OUT/bin/*'

    # If we're targeting another platform, build the std lib for that. We can't use CONFIG.OS as this is always set to
    # the host OS for tools.
    if CONFIG.TARGET_OS != CONFIG.HOSTOS or CONFIG.TARGET_ARCH != CONFIG.HOSTARCH:
        cmd += f' && (export GOOS={CONFIG.TARGET_OS} && export GOARCH={CONFIG.TARGET_ARCH} && $OUT/bin/go install std)'

    #TODO(jpoole): Add the option to compile these with -race for the race detector as well. This need to be plumbed
    # through to the go_library rules as well though.
    return build_rule(
        name = name,
        srcs = [download],
        cmd = cmd,
        outs = [name],
        entry_points = {
            'go': f'{name}/bin/go',
            'gofmt': f'{name}/bin/gofmt',
        },
        binary = True,
        visibility = visibility,
    )


def go_library(name:str, srcs:list, asm_srcs:list=None, hdrs:list=None, out:str=None, deps:list=[],
               visibility:list=None, test_only:bool&testonly=False, complete:bool=True,
               _needs_transitive_deps=False, _all_srcs=False, cover:bool=True,
               filter_srcs:bool=True, _link_private:bool=False, _link_extra:bool=True, _abi:str=False,
               _generate_import_config:bool=True, import_path:str='', labels:list=[]):
    """Generates a Go library which can be reused by other rules.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      asm_srcs (list): Source files to assemble with `go tool assemble`.
      hdrs (list): Header files needed for assembly. Has no effect if asm_srcs is not given.
      out (str): Name of the output library to compile (defaults to name suffixed with .a)
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      complete (bool): Indicates whether the library is complete or not (ie. buildable with
                       `go tool build -complete`). In nearly all cases this is True (the main
                       exception being for cgo).
      cover (bool): Indicates whether this library should be considered for coverage annotations.
                    Libraries are only annotated when using `plz cover` (or `plz build -c cover`),
                    but if this is false they never will be. Can be useful for e.g. third-party
                    code that you never want to be instrumented.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      import_path (str): If set, this will override the import path of the generated go package.
    """
    out = out or name + '.a'
    link_labels = []
    src_labels = []
    private = out.startswith('_')

    if _generate_import_config:
        output = out.removesuffix(".a")
        import_cfg = build_rule(
            name=name,
            tag='import_config',
            cmd = _write_import_config_cmd(out, import_path),
            outs = [f'{output}.importconfig'],
            visibility=visibility,
            test_only=test_only,
            labels=labels,
        )
        exported_deps = [import_cfg]
    else:
        exported_deps = []

    if _link_private or not private:
        src_labels = ['link:plz-out/go/src/${PKG}', 'go_src']
        if not private:
            link_labels = ['link:plz-out/go/pkg/${GOOS}_${GOARCH}/${PKG}']
        libname = out[:-2] if len(out) > 2 else out
        if libname != basename(package_name()) and _link_extra:
            # Libraries that are in a directory not of their own name will need the sources in
            # a subdirectory for go to be able to transparently import them.
            src_labels += [f'link:plz-out/go/src/$PKG/{libname}']
    if asm_srcs:
        abi_rule = build_rule(
            name = name,
            tag = 'abi',
            srcs = {
                'asm': asm_srcs,
                'hdrs': hdrs,
            },
            outs = [name + '.abi'],
            building_description = 'Creating ABI...',
            cmd = 'eval `"$TOOL" env` && "$TOOL" tool asm -trimpath "$TMP_DIR" -I ${GOROOT}/pkg/include -D GOOS_${OS} -D GOARCH_${ARCH} -gensymabis -o "$OUT" $SRCS_ASM',
            tools=[CONFIG.GO_TOOL],
            test_only = test_only,
            labels=labels,
        )
        lib_rule = go_library(
            name = f'_{name}#lib',
            srcs = srcs,
            deps = deps,
            test_only = test_only,
            complete = False,
            cover = cover,
            _abi = abi_rule,
            _needs_transitive_deps = _needs_transitive_deps,
            _all_srcs = _all_srcs,
            _generate_import_config=False,
            labels=labels,
        )
        asm_rule = build_rule(
            name = name,
            tag = 'asm',
            srcs = {
                'asm': asm_srcs,
                'hdrs': hdrs,
                'hdr': [lib_rule + '|h'],
            },
            outs = [name + '.o'],
            building_description = 'Assembling...',
            cmd = 'eval `"$TOOL" env` && "$TOOL" tool asm -trimpath "$TMP_DIR" -I ${GOROOT}/pkg/include -D GOOS_${GOOS} -D GOARCH_${GOARCH} -o "$OUT" $SRCS_ASM',
            tools=[CONFIG.GO_TOOL],
            test_only = test_only,
            labels=labels,
        )
        return build_rule(
            name = name,
            srcs = {
                'lib': [lib_rule + '|o'],
                'asm': [asm_rule],
            },
            outs=[out],
            tools=[CONFIG.GO_TOOL],
            cmd = 'cp $SRCS_LIB "$OUT" && chmod +w "$OUT" && "$TOOL" tool pack r "$OUT" $SRCS_ASM',
            visibility = visibility,
            building_description = 'Packing...',
            requires = ['go'],
            labels = labels+link_labels,
            provides =  {'go': ':' + name, 'go_src': lib_rule},
            test_only = test_only,
            exported_deps = exported_deps,
            deps = deps,
        )

    # go_test and cgo_library need access to the sources as well.
    src_rule = filegroup(
        name = name,
        tag = 'srcs',
        srcs=srcs,
        exported_deps=deps,
        visibility=visibility,
        requires=['go'],
        labels = labels + src_labels,
        test_only=test_only,
    )

    tools = { 'go': [CONFIG.GO_TOOL] }
    if filter_srcs:
        tools['filter'] = [CONFIG.GO_FILTER_TOOL]

    if _abi:
        outs = {
            'o': [out],
            'h': [name + '.h'],
        }
        srcs = {
            'go': srcs,
            'abi': [_abi],
        }
    else:
        outs = [out]

    return build_rule(
        name=name,
        srcs=srcs,
        deps=deps,
        internal_deps = [src_rule],
        outs=outs,
        cmd=_go_library_cmds(complete=complete, all_srcs=_all_srcs, cover=cover, filter_srcs=filter_srcs, abi=_abi),
        visibility=visibility,
        building_description="Compiling...",
        requires=['go', 'go_src'] if _all_srcs else ['go'],
        provides={'go': ':' + name, 'go_src': src_rule},
        labels = labels+link_labels,
        test_only=test_only,
        tools=tools,
        needs_transitive_deps=_needs_transitive_deps,
        exported_deps = exported_deps,
    )

def _generate_pkg_import_cfg_cmd(out, pkg_location, handle_basename_eq_dirname=False):
    """
    Generates a .importconfig file for all .a files within a go pkg directory for use with
    `go tool {compile/link} -importcfg`. This is used to generate a config file for the go SDK and third party
    dependencies.
    """
    pkg_location = f'{pkg_location}/pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}'
    find_archives = f'find {pkg_location} -name "*.a"'
    remove_pkg_location = f'sed -e s=^{pkg_location}/=='
    remove_ext = 'sed -e s="\.a\$"=='

    if handle_basename_eq_dirname:
        format_packagefile_directive = ' '.join([
            'while read -r IMPORT; do',
                'echo "packagefile $IMPORT=' + pkg_location + '/$IMPORT.a";'
                'if [ "$(basename $(dirname $IMPORT))" == "$(basename $IMPORT)" ];',
                    'then echo "packagefile $(dirname $IMPORT)=' + pkg_location + '/$IMPORT.a";',
                'fi;',
            'done',
        ])
    else:
        format_packagefile_directive = 'xargs -I{} echo "packagefile {}=' + pkg_location + '/{}.a"'

    return f'{find_archives} | {remove_pkg_location} | {remove_ext} | {format_packagefile_directive} | sort -u > {out}'
def _aggregate_import_cfg_cmd():
    return 'find . -name "*.importconfig" | xargs -I{} cat {} | sort -u >> importconfig'

def _trim_import_path(pkg):
    parts = pkg.split("/")
    name = parts[-1]
    dir = parts[-2]

    if name == dir:
        return pkg.removesuffix(f'/{name}')
    else:
        return pkg

def _write_import_config_cmd(out, import_path):
    name = out.removesuffix(".a")
    pkg = package_name()
    import_path = _get_import_path(import_path)

    cmd = f'echo packagefile {import_path}/{name}=$PKG_DIR/{out} > $OUT'
    if pkg.endswith(name):
        cmd = f'{cmd} && echo packagefile {import_path}=$PKG_DIR/{out} >> $OUT'
    return cmd

def _get_import_path(import_path):
    if import_path:
        return import_path

    pkg = package_name()

    if CONFIG.GO_IMPORT_PATH:
        return f'{CONFIG.GO_IMPORT_PATH}/{pkg}'

    return pkg

def cgo_library(name:str, srcs:list=[], go_srcs:list=[], c_srcs:list=[], hdrs:list=[],
                out:str=None, compiler_flags:list&cflags=[], linker_flags:list&ldflags=[], pkg_config:list=[],
                subdir:str='', deps:list=[], visibility:list=None, test_only:bool&testonly=False, import_path:str=''):
    """Generates a Go library which can be reused by other rules.

    Note that by its nature this is something of a hybrid of Go and C rules. It can depend
    on C / C++ rules, given the limitations of cgo (i.e. you will have to interact with them
    through a C interface, although the objects themselves can contain C++). As mentioned
    below, you will likely be better off wrapping your dependencies into a cc_static_library
    rule and depending on that rather than depending directly on cc_library rules.

    Note also that this does not honour Go's syntactic comments; you have to explicitly
    specify which Go files are cgo vs. which are not, as well as C headers & sources and
    any required cflags or ldflags.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile that have 'import "C"' declarations in them.
      go_srcs (list): Any Go source files that do *not* have 'import "C"' declarations.
      c_srcs (list): Any C source files to include.
      hdrs (list): Any C header files to include.
      out (str): Name of output file. Defaults to name + '.a'.
      compiler_flags (list): List of compiler flags to be passed when compiling the C code.
      linker_flags (list): List of linker flags to be passed when linking a Go binary.
      pkg_config (list): List of packages to pass to pkg-config.
      subdir (str): Subdirectory that source files are in. Required if they're not in the
                    current directory.
      deps (list): Dependencies. Note that if you intend to depend on cc_library rules,
                   you will likely be better off wrapping them into a cc_static_library
                   and depending on that.
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      import_path (str): If set, this will override the import path of the generated go package.
    """
    assert srcs or go_srcs, 'At least one of srcs and go_srcs must be provided'

    if not srcs:
        return go_library(
            name = name,
            srcs = go_srcs,
            out = out,
            deps = deps,
            import_path = import_path,
            visibility = visibility,
            test_only = test_only,
        )

    file_srcs = [src for src in srcs if not src.startswith('/') and not src.startswith(':')]
    post_build = lambda rule, output: [add_out(rule, 'c' if line.endswith('.c') else 'go', line) for line in output]
    subdir2 = (subdir + '/') if subdir and not subdir.endswith('/') else subdir

    # Resolve the import_path early
    # _write_import_config_cmd won't resolve it again
    import_path = _get_import_path(import_path)

    cgo_rule = build_rule(
        name = name,
        tag = 'cgo',
        srcs = srcs + hdrs,
        outs = {
            'go': [subdir2 + src.replace('.go', '.cgo1.go') for src in file_srcs] + [subdir2 + '_cgo_gotypes.go'],
            'c': [subdir2 + src.replace('.go', '.cgo2.c') for src in file_srcs] + [subdir2 + '_cgo_export.c'],
            'h': [subdir2 + '_cgo_export.h'],
        },
        cmd = ' && '.join([
            (f'OUT_DIR="$TMP_DIR/{subdir}"') if subdir else 'OUT_DIR="$TMP_DIR"',
            'mkdir -p "$OUT_DIR"',
            'cd $PKG_DIR/' + subdir,
            f'$TOOL tool cgo -objdir "$OUT_DIR" -importpath {import_path} *.go',
            # Remove the .o file which BSD sed gets upset about in the next command
            'rm -f "$OUT_DIR"/_cgo_.o "$OUT_DIR"/_cgo_main.c',
            # cgo leaves absolute paths in these files which we must get rid of :(
            'find "$OUT_DIR" -type f -maxdepth 1 | xargs sed -i -e "s|"$TMP_DIR"/||g"',
            'cd "$TMP_DIR"',
            f'ls {subdir2}*.c {subdir2}*.go',
        ]),
        tools = [CONFIG.GO_TOOL],
        post_build = post_build if file_srcs != srcs else None,
        requires = ['go', 'cc_hdrs'],
    )

    # Compile the various bits
    c_rule = c_library(
        name = f'_{name}#c',
        srcs = [cgo_rule + '|c'] + c_srcs,
        hdrs = [cgo_rule + '|h'] + hdrs,
        compiler_flags = compiler_flags + [
            '-Wno-error',
            '-Wno-unused-parameter',  # Generated code doesn't compile clean
        ],
        pkg_config_libs = pkg_config,
        test_only = test_only,
        deps = deps,
    )
    go_rule = go_library(
        name = f'_{name}#go',
        srcs = [cgo_rule + '|go'] + go_srcs,
        test_only = test_only,
        complete = False,
        deps = deps,
        _generate_import_config=False,
    )

    output = out.removesuffix(".a") if out else name
    import_config = build_rule(
        name=name,
        tag='import_config',
        cmd = _write_import_config_cmd(f'{output}.a', import_path),
        outs = [f'{output}.importconfig'],
        visibility=visibility,
        test_only=test_only,
    )

    # And finally combine the compiled C code into the Go archive object so go tool link can find it later.
    return _merge_cgo_obj(
        name = name,
        a_rule = f':_{name}#go',
        o_rule = c_rule,
        visibility = visibility,
        test_only = test_only,
        linker_flags = linker_flags,
        out = out,
        labels = ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)],
        provides = {
            'go': ':' + name,
            'go_src': go_rule,
            'cgo': c_rule,
        },
        deps = deps,
        exported_deps=[import_config],
    )


def _merge_cgo_obj(name, a_rule, o_rule=None, visibility=None, test_only=False, tag='',
                   linker_flags:list=[], deps=None, exported_deps=None, provides=None, out=None, labels:list=[]):
    """Defines a rule to merge a cgo object into a Go library."""
    if o_rule:
        cmd = 'cp $SRCS_A "$OUT" && chmod +w "$OUT" && "$TOOLS_AR" x $SRCS_O && "$TOOLS_GO" tool pack r "$OUT" *.o'
    else:
        cmd = 'cp $SRCS_A "$OUT" && chmod +w "$OUT" && "$TOOLS_AR" x $PKG_DIR/*#c.a && "$TOOLS_GO" tool pack r "$OUT" *.o'

    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            'a': [a_rule],
            'o': [o_rule] if o_rule else [],
        },
        outs = [out or name + '.a'],
        cmd = cmd,
        tools = {
            'go': [CONFIG.GO_TOOL],
            'ar': [CONFIG.AR_TOOL],
        },
        visibility = visibility,
        test_only = test_only,
        labels = ['cc:ld:' + flag for flag in linker_flags] + labels,
        requires = ['go', 'cgo'],
        provides = provides,
        deps = deps,
        exported_deps = exported_deps,
    )


def go_binary(name:str, srcs:list=[], asm_srcs:list=[], out:str=None, deps:list=[], data:list=None,
              visibility:list=None, test_only:bool&testonly=False, static:bool=CONFIG.GO_DEFAULT_STATIC,
              filter_srcs:bool=True, definitions:str|list|dict=None, stamp:bool=False):
    """Compiles a Go binary.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files, one of which contains the main function.
      asm_srcs (list): Assembly source files.
      out (str): Name of the output file to create. Defaults to the same as `name`.
      deps (list): Dependencies
      data (list): Runtime dependencies of this rule.
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
      stamp (bool): Allows this rule to gain access to information about SCM revision etc
                    via env vars. These can be useful to pass into `definitions`.
    """
    lib = go_library(
        name=f'_{name}#lib',
        srcs=srcs or [name + '.go'],
        filter_srcs=filter_srcs,
        asm_srcs=asm_srcs,
        deps=deps,
        test_only=test_only,
        _link_private = True,
        _link_extra = False,
        _generate_import_config=False,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions)
    return build_rule(
        name=name,
        srcs=[lib],
        deps=deps,
        data=data,
        outs=[out or name],
        cmd=cmds,
        building_description="Linking...",
        needs_transitive_deps=True,
        binary=True,
        output_is_complete=True,
        test_only=test_only,
        tools=tools,
        visibility=visibility,
        requires=['go'],
        pre_build=_collect_linker_flags(static),
        stamp = stamp,
    )


def go_test(name:str, srcs:list, data:list|dict=None, deps:list=[], worker:str='', visibility:list=None,
            flags:str='', sandbox:bool=None, cgo:bool=False, filter_srcs:bool=True,
            external:bool=False, timeout:int=0, flaky:bool|int=0, test_outputs:list=[],
            labels:list&features&tags=[], size:str=None, static:bool=CONFIG.GO_DEFAULT_STATIC,
            definitions:str|list|dict=None):
    """Defines a Go test rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      worker (str): Reference to worker script, A persistent worker process that is used to set up the test.
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      cgo (bool): True if this test depends on a cgo_library.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      external (bool): True if this test is external to the library it's testing, i.e. it uses the
                       feature of Go that allows it to be in the same directory with a _test suffix.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
    """
    # Unfortunately we have to recompile this to build the test together with its library.
    lib_rule = go_library(
        name = '_%s#lib' % name,
        srcs = srcs,
        out = name + ('_lib.a' if cgo else '.a'),
        deps = deps,
        labels = labels,
        test_only = True,
        filter_srcs = filter_srcs,
        _all_srcs = not external,
        _link_extra = False,
        complete = False,
        _generate_import_config=False # This should be generated by the `_replace_test_package` post build function
    )
    if cgo:
        lib_rule = _merge_cgo_obj(
            name = name,
            tag='cgo',
            a_rule = lib_rule,
            visibility = visibility,
            labels = labels + ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)],
            test_only = True,
            deps = deps,
        )

    main_rule = go_test_main(
        name = name,
        _tag = 'main',
        srcs = srcs,
        deps = deps,
        test_only = True,
        _post_build = lambda name, output: _replace_test_package(name, output, static, definitions=definitions, cgo=cgo),
        labels = labels,
    )

    deps += [lib_rule]
    lib_rule = go_library(
        name='_%s#main_lib' % name,
        srcs=[main_rule],
        deps=deps,
        _needs_transitive_deps=True,  # Rather annoyingly this is only needed for coverage
        test_only=True,
        _generate_import_config=False,
        labels=labels,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, gcov=cgo)

    test_cmd = '$TEST %s 2>&1 | tee $TMP_DIR/test.results' % flags
    if worker:
        test_cmd = f'$(worker {worker}) && {test_cmd} '
        deps += [worker]

    if CONFIG.GO_TEST_ROOT_COMPAT:
        # This is a workaround for remote execution; $RESULTS_FILE is set to a relative path remotely.
        test_cmd = f'export TEST=./$(basename $TEST) && mkdir -p $PKG_DIR && mv $TEST $PKG_DIR && cd $PKG_DIR && {test_cmd}'
        for out in test_outputs:
            test_cmd += f' && mv {out} $TMP_DIR/{out}'

    return build_rule(
        name=name,
        srcs=[lib_rule],
        data=data,
        deps=deps,
        outs=[name],
        tools=tools,
        cmd=cmds,
        test_cmd=test_cmd,
        visibility=visibility,
        test_sandbox=sandbox,
        test_timeout=timeout,
        size = size,
        flaky=flaky,
        test_outputs=test_outputs,
        requires=['go', 'test'],
        labels=labels,
        binary=True,
        test=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
    )


def go_benchmark(name:str, srcs:list, data:list|dict=None, deps:list=[], visibility:list=None,
                 sandbox:bool=None, cgo:bool=False, filter_srcs:bool=True, external:bool=False, timeout:int=0,
                 labels:list&features&tags=None, static:bool=CONFIG.GO_DEFAULT_STATIC, definitions:str|list|dict=None,
                 test_only=True):
    """Defines a Go test suite that will be run as a benchmark.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      cgo (bool): True if this test depends on a cgo_library.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      external (bool): True if this test is external to the library it's testing, i.e. it uses the
                       feature of Go that allows it to be in the same directory with a _test suffix.
      timeout (int): Timeout in seconds to allow the test to run for.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
       test_only (bool): If True, is only visible to test rules.
    """
    # Unfortunately we have to recompile this to build the test together with its library.
    lib_rule = go_library(
        name = '_%s#lib' % name,
        srcs = srcs,
        out = name + ('_lib.a' if cgo else '.a'),
        deps = deps,
        filter_srcs = filter_srcs,
        _all_srcs = not external,
        _link_extra = False,
        complete = False,
        labels = labels,
        test_only = test_only,
    )
    if cgo:
        lib_rule = _merge_cgo_obj(
            name = name,
            tag = 'cgo',
            a_rule = lib_rule,
            visibility = visibility,
            labels = ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)] + labels,
            deps = deps,
            test_only = test_only,
        )
    main_rule = go_test_main(
        name = name,
        _tag = 'main',
        srcs = srcs,
        deps = deps,
        benchmark=True,
        _post_build = lambda name, output: _replace_test_package(name, output, static, definitions=definitions, cgo=cgo),
        test_only = test_only,
    )
    deps += [lib_rule]
    lib_rule = go_library(
        name='_%s#main_lib' % name,
        srcs=[main_rule],
        deps=deps,
        _generate_import_config=False,
        labels = labels,
        test_only = test_only,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, gcov=cgo)

    return build_rule(
        name=name,
        srcs=[lib_rule],
        data=data,
        deps=deps,
        outs=[name],
        tools=tools,
        cmd=cmds,
        visibility=visibility,
        test_sandbox=sandbox,
        test_timeout=timeout,
        requires=['go', 'test'],
        labels=labels,
        binary=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
        test_only=test_only,
    )

def go_test_main(name:str, srcs:list, test_only:bool=False,
                 deps:list=[], visibility:list=None, _post_build:function=None, _tag=None, benchmark=False,
                 labels:list=[]):
    """Outputs the main file for a Go test.

    This essentially does the test discovery and templates out the entry point from it. Note that
    it only generates the main; you will likely need to arrange for compilation of the inputs via
    a separate go_library rule.

    Args:
      name: Name of the rule
      srcs: Source .go files that define the tests.
      test_only: If True, can only be consumed by tests (or other test_only rules).
      deps: Any additional dependencies
      visibility: Visibility of the rule.
      labels: Any labels to apply to this rule.
    """
    cmd = f'"$TOOLS" --import_path "{CONFIG.GO_IMPORT_PATH}" -o $OUT'
    if benchmark:
        cmd = f'{cmd} --benchmark'
    cmds = {
        'dbg': f'{cmd} $SRCS',
        'opt': f'{cmd} $SRCS',
    }

    if not benchmark:
        cmds['cover'] = f'{cmd} --dir . $SRCS'

    return build_rule(
        name = name,
        tag = _tag,
        srcs = srcs,
        outs = [name + '_main.go'],
        deps = deps,
        cmd = cmds,
        needs_transitive_deps = True,  # Need all dependencies to template coverage variables
        requires = ['go', 'go_src'],
        test_only = test_only,
        tools = [CONFIG.GO_TEST_TOOL],
        post_build = _post_build,
        visibility = visibility,
        labels = labels,
    )


def cgo_test(name:str, srcs:list, data:list=None, deps:list=None, visibility:list=None,
             flags:str='', sandbox:bool=None, timeout:int=0, flaky:bool|int=0,
             test_outputs:list=None, labels:list&features&tags=None, size:str=None, static:bool=False):
    """Defines a Go test rule over a cgo_library.

    If the library you are testing is a cgo_library, you must use this instead of go_test.
    It's ok to depend on a cgo_library though as long as it's not the same package
    as your test; in that (any any other case of testing a go_library) you must use go_test.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     It may not be easy to make cgo tests work when linked statically; depending
                     on your toolchain it may not be possible or may fail.
    """
    return go_test(
        name = name,
        srcs = srcs,
        data = data,
        deps = deps,
        cgo = True,
        static = static,
        visibility = visibility,
        flags = flags,
        sandbox = sandbox,
        timeout = timeout,
        flaky = flaky,
        test_outputs = test_outputs,
        labels = labels,
        size = size,
    )


def go_get(name:str, get:str|list, repo:str='', deps:list=[], exported_deps:list=None,
           visibility:list=None, patch:str|list|dict=None, binary:bool=False, test_only:bool&testonly=False,
           install:list|dict=None, revision:str|list=None, strip:list|dict=None, hashes:list=None,
           extra_outs:list=[], licences:list=None, module_major_version:str|list=''):
    """Defines a dependency on a third-party Go library.

    Note that unlike a normal `go get` call, this does *not* install transitive dependencies.
    You will need to add those as separate rules; `go list -f '{{.Deps}}' <package>` can be
    useful to discover what they should be.

    Note also that while a single go_get is sufficient to compile all parts of a library,
    one may also want separate ones for a binary. Since two rules can't both output the same
    source files (and you only want to download them once anyway) you should handle that by
    marking the non-binary rule as a dependency of the binary one - if you don't there may
    be warnings issued about conflicting output files.

    Args:
      name (str): Name of the rule
      get (str): Target to get (eg. "github.com/gorilla/mux"). Can also be a list of multiple in
                 which case they are fetched separately and compiled together, which can be useful
                 for avoiding issues with circular dependencies.
      repo (str): Location of a Git repository to fetch from.
      deps (list): Dependencies
      exported_deps (list): Dependencies to make available to anything using this rule.
      visibility (list): Visibility specification
      patch (str | list | dict): Patch file(s) to apply. If the dict form is used, each key should correspond
                                 to a target in 'get', with the value defining the patch file(s) to apply to
                                 that target.
      binary (bool): True if the output of the rule is a binary.
      test_only (bool): If true this rule will only be visible to tests.
      install (list | dict): Only install listed (sub)packages. If the dict form is used, each key should
                             correspond to a target in 'get', with the value defining the list of packages
                             to install for that target. Specify the empty string as an element in the list
                             to install a target's root package.
      revision (str): Git hash to check out before building. Only works for git at present,
                      not for other version control systems.
      strip (list | dict): List of paths to strip from the target after downloading but before building it.
                           If the dict form is used, each key should correspond to a target in 'get', with
                           the value defining the paths to strip from that target.
      hashes (list): List of hashes to verify the downloaded sources against.
      extra_outs (list): List of additional output files after the compile.
      licences (list): Licences this rule is subject to.
      module_major_version (str): The go module major version. This rule is not module aware so when a go module does
                                  a major version release, the import path may no longer match the repository structure.
                                  This rule allows us to map the source path in the repo github.com/some/repo/main.go to
                                  the actual source path github.com/some/repo/v2/main.go.
    """
    def get_param_as_list(value, key):
        if not value:
            return []
        elif isinstance(value, str):
            return [value]
        elif isinstance(value, list):
            return value
        elif isinstance(value, dict):
            v = value.get(key)
            if not v:
                return []
            if isinstance(v, str):
                return [v]
            elif isinstance(v, list):
                return v
            else:
                error(f"get_param_as_list: unexpected type %s" % type(v))
        else:
            error(f"get_param_as_list: unexpected type %s" % type(value))

    # Given a list of proposed outputs for this rule (which may be paths to .a
    # files or directories), returns outputs that aren't contained within other
    # outputs - e.g.:
    #   remove_redundant_outs(["x/y", "x/z.a", "x/p/q/r", "x/p/q"])
    # returns
    #   ["x/y", "x/z.a", "x/p/q"]
    def remove_redundant_outs(outs):
        new_outs = {r: True for r in outs}
        for r in new_outs.keys():
            dirs = r.split("/")
            for i in range(1, len(dirs)):
                root = "/".join(dirs[0:i])
                if new_outs.get(root):
                    new_outs[r] = False
        return [r for r in new_outs.keys() if new_outs[r]]

    go_rule = f':{name}'
    if isinstance(get, str):
        get = [get]
        revision = [revision]
        tags = ['get']
        module_major_version = [module_major_version]
    else:
        tags = [g.replace('/', '_') for g in get]
        revision = revision or [None for g in get]
        module_major_version = module_major_version or ['' for g in get]
    all_installs = []
    outs = extra_outs
    get_roots = []
    provides = {}
    srcs = []
    for getone, revision, tag, module_major_version in zip(get, revision, tags, module_major_version):
        get_rule, getroot = _go_get_download(
            name = name,
            tag = tag,
            get = getone,
            repo = repo,
            patch = get_param_as_list(patch, getone),
            hashes = hashes,
            test_only = test_only,
            revision = revision,
            strip = get_param_as_list(strip, getone),
            licences = licences,
            module_major_version = module_major_version,
        )
            
        get_roots += [getroot]
        srcs += [get_rule]
        provides = {'go': go_rule, 'go_src': get_rule}
        installone = get_param_as_list(install, getone)
        if not install or (len(get) > 1 and isinstance(install, list)):
            outs += [getroot]
        else:
            for i in installone:
                if not i or i == ".":
                    outs += [getroot + ".a"]
                elif i == "...":
                    get_roots += [getroot]
                    outs += [getroot]
                elif i.endswith("/..."):
                    out = getroot + "/" + i.removesuffix("/...")
                    get_roots += [out]
                    outs += [out]
                else:
                    outs += [f"{getroot}/{i}.a"]

        if installone:
            all_installs += [i if i.startswith(getroot) else (getroot + '/' + i) for i in installone]
        else:
            all_installs += [getone]

    # in case of installing packages using other package sources 
    if not get and not install:
        raise ParseError("must provide get or install!")
    else:
        if srcs == [] and binary == False:
            # we are going to infer the getroot name from the 1st install dependency
            getroot = install[0][:-4] if install[0].endswith('/...') else install[0]
            # NOTE: for this case in the install list I'm expecting full package names 
            outs += [i[:-4] if i.endswith('/...') else i+".a" for i in install]
            provides = {'go': go_rule} # I can't find the sources 

    # Now compile it in a separate step.
    cmd = [
        'export GOPATH="$(find \"$TMP_DIR\" \( -name src -o -name pkg \) -exec dirname {} \; | sort | uniq | tr \'\\n\' \':\' | sed \'s/:$//\')" GO111MODULE="off"',
        '"$TOOLS_GO" install -gcflags "-trimpath \\\"$TMP_DIR\\\"" -asmflags "-trimpath \\\"$TMP_DIR\\\"" ' + ' '.join(all_installs or install),
    ]
    if CONFIG.GOROOT:
        cmd = [f'export GOROOT={CONFIG.GOROOT}'] + cmd
    if package_name():
        cmd += [
            # The outputs tend to end up in subdirectories (Go seems to match them to the location the source came from)
            'rm -rf bin' if binary else 'rm -rf pkg',
            'mv "$PKG_DIR/bin" .' if binary else 'mv "$PKG_DIR/pkg" .',
        ]
    if binary:
        outs = ['bin/' + name]
    else:
        outs = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/{out}' for out in remove_redundant_outs(outs)]
        # Outputs are created one directory down from where we want them.
        # For most it doesn't matter but the top-level one will get lost.
        pkg_get_roots = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/{getroot}' for getroot in get_roots]
        cmd += [f' if [ -f {out}.a ]; then mkdir -p {out} && cp {out}.a {out}; fi' for out in pkg_get_roots]

    a_rule = build_rule(
        name = name,
        tag = "a_rule" if not binary else None,
        outs = outs,
        deps = deps,
        srcs = srcs,
        tools = {
            'go': [CONFIG.GO_TOOL],
        },
        visibility = visibility,
        building_description = 'Compiling...',
        cmd = ' && '.join(cmd),
        binary = binary,
        requires = ['go', 'go_src'],
        test_only = test_only,
        labels = ['link:plz-out/go'],
        sandbox = False,
        needs_transitive_deps = True,
        licences = licences,
    )

    if not binary:
        import_config = build_rule(
            name=name,
            tag='import_config',
            deps = [a_rule],
            visibility = visibility,
            test_only = test_only,
            cmd = _generate_pkg_import_cfg_cmd('"$OUT"', '"$PKG_DIR"', True),
            outs = [f'{name}.importconfig'],
        )
        exported_deps = exported_deps + [import_config] if exported_deps else [import_config]

        return filegroup(
            name = name,
            srcs = [a_rule],
            deps = deps,
            exported_deps = exported_deps,
            provides = provides,
            visibility = visibility,
            needs_transitive_deps = True,
            test_only = test_only,
            requires = ['go'],
            binary = binary,
        )
    else:
        return a_rule


def _go_get_download(name:str, tag:str, get:str, repo:str='', patch:list=[], hashes:list=None,
                     test_only:bool&testonly=False, revision:str=None, strip:list=None,
                     labels:list=[], licences:list=None, module_major_version:str):
    if hashes and not revision:
        log.warning("You shouldn't specify hashes on go_get without specifying revision as well")
    labels = [f'go_get:{get}@{revision}' if revision else f'go_get:{get}']
    getroot = get[:-4] if get.endswith('/...') else get
    subdir = 'src/' + getroot
    revision = revision or 'master'

    # Some special optimisation for github, which lets us download zipfiles at a particular sha instead of
    # cloning the whole repo. Obviously that is a lot faster than cloning entire repos.
    if repo.startswith('github.com'):
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, repo, revision, module_major_version)
    elif get.startswith('github.com'):
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, getroot, revision, module_major_version)
    elif get.startswith('golang.org/x/') and not repo:
        # We know about these guys...
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, 'github.com/golang/' + getroot[len('golang.org/x/'):], revision, module_major_version)
    elif get.startswith('google.golang.org/grpc') and not repo:
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, 'github.com/grpc/grpc-go' + getroot[len('google.golang.org/grpc'):], revision, module_major_version)
    else:
        get_deps = []
        if repo:
            # we've been told exactly where to get the source from.
            cmd = [f'git clone --branch {revision} --depth=1 --shallow-submodules --no-tags {repo} src/{getroot}']
        else:
            # Ultimate fallback to go get.
            # This has some more restrictions than the above (e.g. go get won't fetch a directory
            # with no Go files in it, even if passed -d).
            cmd = [
                'rm -rf src pkg',
                'export GOPATH="$TMP_DIR" GO111MODULE="off"',
                '$TOOL get -d ' + get,
            ]
        if revision:
            # Annoyingly -C does not work on git checkout :(
            cmd += [f'(cd {subdir} && git checkout -q {revision})']
        cmd += ['find . -name .git | xargs rm -rf']
        tools = [CONFIG.GO_TOOL]
    if patch:
        cmd += [f'for p in "$TMP_DIR"/$SRCS_PATCH; do patch -d {subdir} -p1 < $p; done']
    if strip:
        cmd += [f'rm -rf {subdir}/{s}' for s in strip]
    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            'patch': patch,
            'get': get_deps,
        },
        outs = [subdir],
        tools = tools,
        building_description = 'Fetching...',
        cmd = ' && '.join(cmd),
        requires = ['go'],
        test_only = test_only,
        labels = labels + ['link:plz-out/go'],
        hashes = hashes,
        sandbox = False,
        licences = licences,
    ), getroot


def _go_github_repo_cmd(name, get, repo, revision, module_major_version):
    """Returns a partial command to fetch a Go repo from Github."""
    parts = get.split('/')
    out = '/'.join(parts[:3])
    if repo.count('/') >= 2:
        parts = repo.split('/')
        repo = '/'.join(parts[:3])
        dest = parts[2]
    else:
        dest = parts[-1]
    remote_rule = remote_file(
        name = name + '-' + parts[-1],
        _tag = 'download',
        url = f'https://{repo}/archive/{revision}.zip',
        out = name + '-' + parts[-1] + '.zip',
    )

    cmds = [
        'rm -rf src/' + out,
        '"$TOOL" x $SRCS_GET',
    ]
    if module_major_version:
        cmds += [
            f'mkdir -p src/{out}',
            f'mv {dest}*/ src/{out}/{module_major_version}'
        ]
    else:
        cmds += [f'mv {dest}*/ src/{out}']

    return cmds, [remote_rule], [CONFIG.JARCAT_TOOL]


def _set_go_env():
    if CONFIG.GOROOT:
        go_root = CONFIG.GOROOT
    elif CONFIG.GO_TOOL.startswith(":") or CONFIG.GO_TOOL.startswith("//"):
        label, _, _ = CONFIG.GO_TOOL.rpartition('|')
        go_root = f'$(dirname $(dirname $TOOLS_GO))'
    else:
        go_root = '$("$TOOLS_GO" env GOROOT)'
    return f'export GOPATH=$TMP_DIR && export GOROOT={go_root}'

def _go_library_cmds(complete=True, all_srcs=False, cover=True, filter_srcs=True, abi=False):
    """Returns the commands to run for building a Go library."""
    filter_cmd = 'export SRCS="$(\"${TOOLS_FILTER}\" ${SRCS})"; ' if filter_srcs else ''
    # Invokes the Go compiler.
    complete_flag = '-complete ' if complete else ''
    out_cmd = ' -o "$OUTS_O" -symabis $SRCS_ABI -asmhdr "$OUTS_H"' if abi else ' -o "$OUT"'
    compile_cmd = f'"$TOOLS_GO" tool compile -importcfg importconfig -trimpath "$TMP_DIR" {complete_flag} -pack {out_cmd}'
    # Annotates files for coverage.
    cover_cmd = 'for SRC in $SRCS; do BN=$(basename $SRC); "$TOOLS_GO" tool cover -mode=set -var=GoCover_${BN//[.-]/_} $SRC > _tmp.go && mv -f _tmp.go $SRC; done'

    gen_import_cfg = _set_go_env() + ' && ' + _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')
    gen_import_cfg += ' && ' + _aggregate_import_cfg_cmd()
    prefix = ('export SRCS="$PKG_DIR/*.go"; ' + gen_import_cfg) if all_srcs else gen_import_cfg
    cmds = {
        'dbg': f'{prefix}; {filter_cmd}{compile_cmd} -N -l $SRCS',
        'opt': f'{prefix}; {filter_cmd}{compile_cmd} $SRCS',
    }
    if cover:
        cmds['cover'] = f'{prefix}; {filter_cmd}{cover_cmd} && {compile_cmd} $SRCS'
    return cmds


def _go_binary_cmds(static=False, ldflags='', pkg_config='', definitions=None, gcov=False):
    """Returns the commands to run for linking a Go binary."""

    _link_cmd = f'"$TOOLS_GO" tool link -importcfg importconfig -tmpdir "$TMP_DIR" -extld "$TOOLS_LD" -o "$OUT"'

    gen_import_cfg = _set_go_env() + ' && ' + _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')
    gen_import_cfg += ' && ' + _aggregate_import_cfg_cmd()

    linkerdefs = []
    if definitions is None:
        pass
    elif isinstance(definitions, str):
        linkerdefs += [f'{definitions}']
    elif isinstance(definitions, list):
        linkerdefs += [f'{linkerdef}' for linkerdef in definitions]
    elif isinstance(definitions, dict):
        linkerdefs = [k if v is None else f'{k}={v}' for k, v in sorted(definitions.items())]

    defs = ' '.join([f'-X "{linkerdef}"' for linkerdef in linkerdefs])

    if static:
        flags = f'-linkmode external -extldflags "-static {ldflags} {pkg_config}"'
    elif ldflags or pkg_config:
        flags = f'-extldflags "{ldflags} {pkg_config}"'
    else:
        flags = f''

    if len(defs) > 0:
        flags += " " + defs

    cmds = {
        'dbg': f'{gen_import_cfg} && {_link_cmd} {flags} $SRCS',
        'opt': f'{gen_import_cfg} && {_link_cmd} {flags} -s -w $SRCS',
    }
    if gcov and CONFIG.CPP_COVERAGE:
        cmds['cover'] = f'{gen_import_cfg} && {_link_cmd} {flags} -extldflags="-lgcov" $SRCS'

    return cmds, {
        'go': [CONFIG.GO_TOOL],
        'ld': [CONFIG.LD_TOOL if CONFIG.LINK_WITH_LD_TOOL else CONFIG.CC_TOOL],
    }


def _go_import_path_cmd(import_path):
    """Returns a partial command which is used for setting up the Go import path."""
    if not import_path:
        return ''
    elif import_path.startswith('/'):
        raise ConfigError('GO_IMPORT_PATH cannot start with a /')
    elif '/' in import_path:
        return ' && mkdir -p %s && ln -s "$TMP_DIR" %s' % (dirname(import_path), import_path)
    else:
        return ' && ln -s "$TMP_DIR" ' + import_path


def _collect_linker_flags(static):
    """Returns a pre-build function to apply transitive linker flags to a go_binary rule."""
    def collect_linker_flags(name):
        ldflags, pkg_config = _get_ldflags_and_pkgconfig(name)
        if ldflags or pkg_config:
            cmds, _ =  _go_binary_cmds(static=static, ldflags=ldflags, pkg_config=pkg_config)
            for k, v in cmds.items():
                set_command(name, k, v)
    return collect_linker_flags


def _get_ldflags_and_pkgconfig(name):
    """Returns the ldflags and pkg-config invocations for a target."""
    labels = get_labels(name, 'cc:')
    ldflags = ' '.join([l[3:] for l in labels if l.startswith('ld:')])
    pkg_config = ' '.join([l[3:] for l in labels if l.startswith('pc:')])
    return (ldflags, f'`pkg-config --libs {pkg_config}`') if pkg_config else (ldflags, '')

def _replace_test_package(name, output, static, definitions, cgo):
    """Post-build function, called after we template the main function.

    The purpose is to replace the real library with the specific one we've
    built for this test which has the actual test functions in it.
    """
    if not name.endswith('#main') or not name.startswith('_'):
        raise ValueError('unexpected rule name: ' + name)
    lib = name[:-5] + '#main_lib'
    new_name = name[1:-5]
    for line in output:
        if line.startswith('Package: '):
            ldflags, pkg_config = _get_ldflags_and_pkgconfig(name)
            pkg_name = line[9:]
            pkg_dir = package_name()

            import_path = f'{CONFIG.GO_IMPORT_PATH}/{pkg_dir}/{pkg_name}' if CONFIG.GO_IMPORT_PATH else f'{pkg_dir}/{pkg_name}'
            import_path = _trim_import_path(import_path)
            import_config_cmd = f'rm -f $PKG_DIR/{pkg_name}.importconfig && echo packagefile {import_path}=$PKG_DIR/{new_name}.a > {pkg_name}.importconfig'

            binary_cmds, _ = _go_binary_cmds(static=static, ldflags=ldflags, pkg_config=pkg_config, definitions, cgo)
            for k, v in binary_cmds.items():
                set_command(new_name, k, f'{import_config_cmd} && {v}')

            for k, v in _go_library_cmds().items():
                set_command(lib, k, f'{import_config_cmd} && {v}')
