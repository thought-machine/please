""" Rules to build Go code.

Go has a strong built-in concept of packages so it's probably a good idea to match Please
rules to Go packages.
"""
def go_toolchain(name:str, url:str|dict = '', version:str = '', hashes:list = [], visibility:list = ["PUBLIC"]):
    """
    Downloads Go and exposes :<name>|go and :<name>|gofmt as entry points. To use this rule add the
    following to your .plzconfig:

    [go]
    GoTool = //.../<name>|go

    Args:
      name (str): Name of the rule.
      url (str | dict): The URL used to download Go. Can be a single string or a dictionary mapping
                        GOOS-GOARCH to URLs i.e. linux-amd64: 'https://...'. Either provide url or version, but not both.
      version (str): The version of Go to download. Go will be downloaded from https://golang.org/dl/...
                     and the rule will use the current platforms GOOS and GOARCH setting. Either provide url or version,
                     but not both.
      hashes (list): A list of possible hashes for the downloaded archive. Optional.
      visibility (list): Visibility specification. Defaults to public.
    """
    if url and version:
        raise ParseError("Either version or url should be provided but not both")

    if version:
        sdk_url = f'https://golang.org/dl/go{version}.{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}.tar.gz'
    else:
        sdk_url = url if isinstance(url, str) else url[f'{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}']

    download = remote_file(
        name = name,
        _tag = 'download',
        url = sdk_url,
        hashes = hashes,
    )

    cmd = 'tar -xf $SRCS && mv go $OUT && chmod +x $OUT/bin/*'
    # If we're targeting another platform, build the std lib for that. We can't use CONFIG.OS as this is always set to
    # the host OS for tools.
    if CONFIG.TARGET_OS != CONFIG.HOSTOS or CONFIG.TARGET_ARCH != CONFIG.HOSTARCH:
        if CONFIG.CGO_ENABLED == "1":
            cgo_vars = f"export CGO_ENABLED={CONFIG.CGO_ENABLED} && export CC=$TOOLS_CC && "
        else:
            cgo_vars = ""
        cmd += f' && ({cgo_vars}export GOOS={CONFIG.TARGET_OS} && export GOARCH={CONFIG.TARGET_ARCH} && $OUT/bin/go install std)'

    #TODO(jpoole): Add the option to compile these with -race for the race detector as well. This need to be plumbed
    # through to the go_library rules as well though.
    return build_rule(
        name = name,
        srcs = [download],
        cmd = cmd,
        outs = [name],
        entry_points = {
            'go': f'{name}/bin/go',
            'gofmt': f'{name}/bin/gofmt',
        },
        tools = {
          "CC": [CONFIG.CGO_CC_TOOL],
        } if CONFIG.CGO_ENABLED == "1" else {},
        binary = True,
        visibility = visibility,
    )


def go_library(name:str, srcs:list, asm_srcs:list=None, hdrs:list=None, out:str=None, deps:list=[],
               visibility:list=None, test_only:bool&testonly=False, complete:bool=True,
               _needs_transitive_deps=False, _all_srcs=False, cover:bool=True,
               filter_srcs:bool=True, _link_private:bool=False, _link_extra:bool=True, _abi:str=False,
               _generate_import_config:bool=True, import_path:str='', labels:list=[], package:str=None):
    """Generates a Go library which can be reused by other rules.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      asm_srcs (list): Source files to assemble with `go tool assemble`.
      hdrs (list): Header files needed for assembly. Has no effect if asm_srcs is not given.
      out (str): Name of the output library to compile (defaults to name suffixed with .a)
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      complete (bool): Indicates whether the library is complete or not (ie. buildable with
                       `go tool build -complete`). In nearly all cases this is True (the main
                       exception being for cgo).
      cover (bool): Indicates whether this library should be considered for coverage annotations.
                    Libraries are only annotated when using `plz cover` (or `plz build -c cover`),
                    but if this is false they never will be. Can be useful for e.g. third-party
                    code that you never want to be instrumented.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      import_path (str): If set, this will override the import path of the generated go package.
      package (str): The package as it would appear at the top of the go source files. Defaults
                     to name.
    """
    package = package or name
    package = out.removesuffix(".a") if out else package
    out = out or package + '.a'
    link_labels = []
    src_labels = []
    private = out.startswith('_')

    if _generate_import_config:
        import_cfg = build_rule(
            name=name,
            tag='import_config',
            cmd = _write_import_config_cmd(package, import_path),
            outs = [f'{package}.importconfig'],
            visibility=visibility,
            test_only=test_only,
            labels=labels,
        )
        exported_deps = [import_cfg]
    else:
        exported_deps = []

    if _link_private or not private:
        src_labels = ['link:plz-out/go/src/${PKG}', 'go_src']
        if not private:
            link_labels = ['link:plz-out/go/pkg/${GOOS}_${GOARCH}/${PKG}']
        libname = out[:-2] if len(out) > 2 else out
        if libname != basename(package_name()) and _link_extra:
            # Libraries that are in a directory not of their own name will need the sources in
            # a subdirectory for go to be able to transparently import them.
            src_labels += [f'link:plz-out/go/src/$PKG/{libname}']
    if asm_srcs:
        abi_rule = build_rule(
            name = name,
            tag = 'abi',
            srcs = {
                'asm': asm_srcs,
                'hdrs': hdrs,
            },
            outs = [name + '.abi'],
            building_description = 'Creating ABI...',
            cmd = 'eval `"$TOOL" env` && "$TOOL" tool asm -trimpath "$TMP_DIR" -I ${GOROOT}/pkg/include -D GOOS_${OS} -D GOARCH_${ARCH} -gensymabis -o "$OUT" $SRCS_ASM',
            tools=[CONFIG.GO_TOOL],
            test_only = test_only,
            labels=labels,
        )
        lib_rule = go_library(
            name = f'_{name}#lib',
            srcs = srcs,
            deps = deps,
            test_only = test_only,
            complete = False,
            cover = cover,
            _abi = abi_rule,
            _needs_transitive_deps = _needs_transitive_deps,
            _all_srcs = _all_srcs,
            _generate_import_config=False,
            labels=labels,
        )
        asm_rule = build_rule(
            name = name,
            tag = 'asm',
            srcs = {
                'asm': asm_srcs,
                'hdrs': hdrs,
                'hdr': [lib_rule + '|h'],
            },
            outs = [name + '.o'],
            building_description = 'Assembling...',
            cmd = 'eval `"$TOOL" env` && "$TOOL" tool asm -trimpath "$TMP_DIR" -I ${GOROOT}/pkg/include -D GOOS_${GOOS} -D GOARCH_${GOARCH} -o "$OUT" $SRCS_ASM',
            tools=[CONFIG.GO_TOOL],
            test_only = test_only,
            labels=labels,
        )
        return build_rule(
            name = name,
            srcs = {
                'lib': [lib_rule + '|o'],
                'asm': [asm_rule],
            },
            outs=[out],
            tools=[CONFIG.GO_TOOL],
            cmd = 'cp $SRCS_LIB "$OUT" && chmod +w "$OUT" && "$TOOL" tool pack r "$OUT" $SRCS_ASM',
            visibility = visibility,
            building_description = 'Packing...',
            requires = ['go'],
            labels = labels+link_labels,
            provides =  {'go': ':' + name, 'go_src': lib_rule},
            test_only = test_only,
            exported_deps = exported_deps,
            deps = deps,
        )

    # go_test and cgo_library need access to the sources as well.
    src_rule = filegroup(
        name = name,
        tag = 'srcs',
        srcs=srcs,
        exported_deps=deps,
        visibility=visibility,
        requires=['go'],
        labels = labels + src_labels,
        test_only=test_only,
    )

    tools = { 'go': [CONFIG.GO_TOOL] }
    if filter_srcs:
        tools['filter'] = [CONFIG.GO_FILTER_TOOL]

    if _abi:
        outs = {
            'o': [out],
            'h': [name + '.h'],
        }
        srcs = {
            'go': srcs,
            'abi': [_abi],
        }
    else:
        outs = [out]

    return build_rule(
        name=name,
        srcs=srcs,
        deps=deps,
        internal_deps = [src_rule],
        outs=outs,
        cmd=_go_library_cmds(complete=complete, all_srcs=_all_srcs, cover=cover, filter_srcs=filter_srcs, abi=_abi),
        visibility=visibility,
        building_description="Compiling...",
        requires=['go', 'go_src'] if _all_srcs else ['go'],
        provides={'go': ':' + name, 'go_src': src_rule},
        labels = labels+link_labels,
        test_only=test_only,
        tools=tools,
        needs_transitive_deps=_needs_transitive_deps,
        exported_deps = exported_deps,
    )

def _generate_pkg_import_cfg_cmd(out, pkg_location, handle_basename_eq_dirname=False):
    """
    Generates a .importconfig file for all .a files within a go pkg directory for use with
    `go tool {compile/link} -importcfg`. This is used to generate a config file for the go SDK and third party
    dependencies.
    """
    pkg_location = f'{pkg_location}/pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}'
    find_archives = f'find {pkg_location} -name "*.a"'
    remove_pkg_location = f'sed -e s=^{pkg_location}/=='
    remove_ext = 'sed -e s="\.a\$"=='

    if handle_basename_eq_dirname:
        format_packagefile_directive = ' '.join([
            'while read -r IMPORT; do',
                'echo "packagefile $IMPORT=' + pkg_location + '/$IMPORT.a";'
                'if [ "$(basename $(dirname $IMPORT))" == "$(basename $IMPORT)" ];',
                    'then echo "packagefile $(dirname $IMPORT)=' + pkg_location + '/$IMPORT.a";',
                'fi;',
            'done',
        ])
    else:
        format_packagefile_directive = 'xargs -I{} echo "packagefile {}=' + pkg_location + '/{}.a"'

    return f'{find_archives} | {remove_pkg_location} | {remove_ext} | {format_packagefile_directive} | sort -u > {out}'
def _aggregate_import_cfg_cmd():
    return 'find . -name "*.importconfig" | xargs -I{} cat {} | sort -u >> importconfig'

def _trim_import_path(pkg):
    parts = pkg.split("/")
    name = parts[-1]
    dir = parts[-2]

    if name == dir:
        return pkg.removesuffix(f'/{name}')
    else:
        return pkg

def _write_import_config_cmd(name, import_path):
    pkg = package_name()
    import_path = _get_import_path(import_path)

    cmd = f'echo packagefile {import_path}/{name}=$PKG_DIR/{name}.a > $OUT'
    if pkg.endswith(name):
        cmd = f'{cmd} && echo packagefile {import_path}=$PKG_DIR/{name}.a >> $OUT'
    return cmd

def _get_import_path(import_path):
    if import_path:
        return import_path

    pkg = package_name()

    if CONFIG.GO_IMPORT_PATH:
        return f'{CONFIG.GO_IMPORT_PATH}/{pkg}' if pkg else CONFIG.GO_IMPORT_PATH

    return pkg

def cgo_library(name:str, srcs:list=[], go_srcs:list=[], c_srcs:list=[], hdrs:list=[],
                out:str=None, compiler_flags:list&cflags=[], linker_flags:list&ldflags=[], pkg_config:list=[],
                subdir:str='', deps:list=[], visibility:list=None, test_only:bool&testonly=False, import_path:str=''):
    """Generates a Go library which can be reused by other rules.

    Note that by its nature this is something of a hybrid of Go and C rules. It can depend
    on C / C++ rules, given the limitations of cgo (i.e. you will have to interact with them
    through a C interface, although the objects themselves can contain C++). As mentioned
    below, you will likely be better off wrapping your dependencies into a cc_static_library
    rule and depending on that rather than depending directly on cc_library rules.

    Note also that this does not honour Go's syntactic comments; you have to explicitly
    specify which Go files are cgo vs. which are not, as well as C headers & sources and
    any required cflags or ldflags.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile that have 'import "C"' declarations in them.
      go_srcs (list): Any Go source files that do *not* have 'import "C"' declarations.
      c_srcs (list): Any C source files to include.
      hdrs (list): Any C header files to include.
      out (str): Name of output file. Defaults to name + '.a'.
      compiler_flags (list): List of compiler flags to be passed when compiling the C code.
      linker_flags (list): List of linker flags to be passed when linking a Go binary.
      pkg_config (list): List of packages to pass to pkg-config.
      subdir (str): Subdirectory that source files are in. Required if they're not in the
                    current directory.
      deps (list): Dependencies. Note that if you intend to depend on cc_library rules,
                   you will likely be better off wrapping them into a cc_static_library
                   and depending on that.
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      import_path (str): If set, this will override the import path of the generated go package.
    """
    assert srcs or go_srcs, 'At least one of srcs and go_srcs must be provided'

    if not srcs:
        return go_library(
            name = name,
            srcs = go_srcs,
            out = out,
            deps = deps,
            import_path = import_path,
            visibility = visibility,
            test_only = test_only,
        )

    file_srcs = [src for src in srcs if not src.startswith('/') and not src.startswith(':')]
    post_build = lambda rule, output: [add_out(rule, 'c' if line.endswith('.c') else 'go', line) for line in output]
    subdir2 = (subdir + '/') if subdir and not subdir.endswith('/') else subdir

    # Resolve the import_path early
    # _write_import_config_cmd won't resolve it again
    import_path = _get_import_path(import_path)

    cgo_rule = build_rule(
        name = name,
        tag = 'cgo',
        srcs = srcs + hdrs,
        outs = {
            'go': [subdir2 + src.replace('.go', '.cgo1.go') for src in file_srcs] + [subdir2 + '_cgo_gotypes.go'],
            'c': [subdir2 + src.replace('.go', '.cgo2.c') for src in file_srcs] + [subdir2 + '_cgo_export.c'],
            'h': [subdir2 + '_cgo_export.h'],
        },
        cmd = ' && '.join([
            (f'OUT_DIR="$TMP_DIR/{subdir}"') if subdir else 'OUT_DIR="$TMP_DIR"',
            'mkdir -p "$OUT_DIR"',
            'cd $PKG_DIR/' + subdir,
            f'$TOOL tool cgo -objdir "$OUT_DIR" -importpath {import_path} *.go',
            # Remove the .o file which BSD sed gets upset about in the next command
            'rm -f "$OUT_DIR"/_cgo_.o "$OUT_DIR"/_cgo_main.c',
            # cgo leaves absolute paths in these files which we must get rid of :(
            'find "$OUT_DIR" -type f -maxdepth 1 | xargs sed -i -e "s|"$TMP_DIR"/||g"',
            'cd "$TMP_DIR"',
            f'ls {subdir2}*.c {subdir2}*.go',
        ]),
        tools = [CONFIG.GO_TOOL],
        post_build = post_build if file_srcs != srcs else None,
        requires = ['go', 'cc_hdrs'],
    )

    # Compile the various bits
    c_rule = c_library(
        name = f'_{name}#c',
        srcs = [cgo_rule + '|c'] + c_srcs,
        hdrs = [cgo_rule + '|h'] + hdrs,
        compiler_flags = compiler_flags + [
            '-Wno-error',
            '-Wno-unused-parameter',  # Generated code doesn't compile clean
        ],
        pkg_config_libs = pkg_config,
        test_only = test_only,
        deps = deps,
    )
    go_rule = go_library(
        name = f'_{name}#go',
        srcs = [cgo_rule + '|go'] + go_srcs,
        test_only = test_only,
        complete = False,
        deps = deps,
        _generate_import_config=False,
    )

    output = out.removesuffix(".a") if out else name
    import_config = build_rule(
        name=name,
        tag='import_config',
        cmd = _write_import_config_cmd(output, import_path),
        outs = [f'{output}.importconfig'],
        visibility=visibility,
        test_only=test_only,
    )

    # And finally combine the compiled C code into the Go archive object so go tool link can find it later.
    return _merge_cgo_obj(
        name = name,
        a_rule = f':_{name}#go',
        o_rule = c_rule,
        visibility = visibility,
        test_only = test_only,
        linker_flags = linker_flags,
        out = out,
        labels = ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)],
        provides = {
            'go': ':' + name,
            'go_src': go_rule,
            'cgo': c_rule,
        },
        deps = deps,
        exported_deps=[import_config],
    )


def _merge_cgo_obj(name, a_rule, o_rule=None, visibility=None, test_only=False, tag='',
                   linker_flags:list=[], deps=None, exported_deps=None, provides=None, out=None, labels:list=[]):
    """Defines a rule to merge a cgo object into a Go library."""
    if o_rule:
        cmd = 'cp $SRCS_A "$OUT" && chmod +w "$OUT" && "$TOOLS_AR" x $SRCS_O && "$TOOLS_GO" tool pack r "$OUT" *.o'
    else:
        cmd = 'cp $SRCS_A "$OUT" && chmod +w "$OUT" && "$TOOLS_AR" x $PKG_DIR/*#c.a && "$TOOLS_GO" tool pack r "$OUT" *.o'

    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            'a': [a_rule],
            'o': [o_rule] if o_rule else [],
        },
        outs = [out or name + '.a'],
        cmd = cmd,
        tools = {
            'go': [CONFIG.GO_TOOL],
            'ar': [CONFIG.AR_TOOL],
        },
        visibility = visibility,
        test_only = test_only,
        labels = ['cc:ld:' + flag for flag in linker_flags] + labels,
        requires = ['go', 'cgo'],
        provides = provides,
        deps = deps,
        exported_deps = exported_deps,
    )


def go_binary(name:str, srcs:list=[], asm_srcs:list=[], out:str=None, deps:list=[], data:list=None,
              visibility:list=None, labels:list=[], test_only:bool&testonly=False, static:bool=CONFIG.GO_DEFAULT_STATIC,
              filter_srcs:bool=True, definitions:str|list|dict=None, stamp:bool=False):
    """Compiles a Go binary.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files, one of which contains the main function.
      asm_srcs (list): Assembly source files.
      out (str): Name of the output file to create. Defaults to the same as `name`.
      deps (list): Dependencies
      data (list): Runtime dependencies of this rule.
      visibility (list): Visibility specification
      labels (list): Labels for this rule.
      test_only (bool): If True, is only visible to test rules.
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
      stamp (bool): Allows this rule to gain access to information about SCM revision etc
                    via env vars. These can be useful to pass into `definitions`.
    """
    lib = go_library(
        name=f'_{name}#lib',
        srcs=srcs or [name + '.go'],
        filter_srcs=filter_srcs,
        asm_srcs=asm_srcs,
        deps=deps,
        labels=labels,
        test_only=test_only,
        _link_private = True,
        _link_extra = False,
        _generate_import_config=False,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions)
    return build_rule(
        name=name,
        srcs=[lib],
        deps=deps,
        data=data,
        outs=[out or name],
        cmd=cmds,
        building_description="Linking...",
        needs_transitive_deps=True,
        binary=True,
        output_is_complete=True,
        test_only=test_only,
        tools=tools,
        visibility=visibility,
        labels=labels,
        requires=['go'],
        pre_build=_collect_linker_flags(static),
        stamp = stamp,
    )


def go_test(name:str, srcs:list, data:list|dict=None, deps:list=[], worker:str='', visibility:list=None,
            flags:str='', sandbox:bool=None, cgo:bool=False, filter_srcs:bool=True,
            external:bool=False, timeout:int=0, flaky:bool|int=0, test_outputs:list=[],
            labels:list&features&tags=[], size:str=None, static:bool=CONFIG.GO_DEFAULT_STATIC,
            definitions:str|list|dict=None):
    """Defines a Go test rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      worker (str): Reference to worker script, A persistent worker process that is used to set up the test.
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      cgo (bool): True if this test depends on a cgo_library.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      external (bool): True if this test is external to the library it's testing, i.e. it uses the
                       feature of Go that allows it to be in the same directory with a _test suffix.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
    """
    # Unfortunately we have to recompile this to build the test together with its library.
    lib_rule = go_library(
        name = '_%s#lib' % name,
        srcs = srcs,
        out = name + ('_lib.a' if cgo else '.a'),
        deps = deps,
        labels = labels,
        test_only = True,
        filter_srcs = filter_srcs,
        _all_srcs = not external,
        _link_extra = False,
        complete = False,
        _generate_import_config=False # This should be generated by the `_replace_test_package` post build function
    )
    if cgo:
        lib_rule = _merge_cgo_obj(
            name = name,
            tag='cgo',
            a_rule = lib_rule,
            visibility = visibility,
            labels = labels + ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)],
            test_only = True,
            deps = deps,
        )

    main_rule = go_test_main(
        name = name,
        _tag = 'main',
        srcs = srcs,
        deps = deps,
        test_only = True,
        _post_build = lambda name, output: _replace_test_package(name, output, static, definitions=definitions, cgo=cgo),
        labels = labels,
    )

    deps += [lib_rule]
    lib_rule = go_library(
        name='_%s#main_lib' % name,
        srcs=[main_rule],
        deps=deps,
        _needs_transitive_deps=True,  # Rather annoyingly this is only needed for coverage
        test_only=True,
        _generate_import_config=False,
        labels=labels,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, gcov=cgo)

    test_cmd = '$TEST %s 2>&1 | tee $TMP_DIR/test.results' % flags
    if worker:
        test_cmd = f'$(worker {worker}) && {test_cmd} '
        deps += [worker]

    if CONFIG.GO_TEST_ROOT_COMPAT:
        # This is a workaround for remote execution; $RESULTS_FILE is set to a relative path remotely.
        test_cmd = f'export TEST=./$(basename $TEST) && mkdir -p $PKG_DIR && mv $TEST $PKG_DIR && cd $PKG_DIR && {test_cmd}'
        for out in test_outputs:
            test_cmd += f' && mv {out} $TMP_DIR/{out}'

    return build_rule(
        name=name,
        srcs=[lib_rule],
        data=data,
        deps=deps,
        outs=[name],
        tools=tools,
        cmd=cmds,
        test_cmd=test_cmd,
        visibility=visibility,
        test_sandbox=sandbox,
        test_timeout=timeout,
        size = size,
        flaky=flaky,
        test_outputs=test_outputs,
        requires=['go', 'test'],
        labels=labels,
        binary=True,
        test=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
    )


def go_benchmark(name:str, srcs:list, data:list|dict=None, deps:list=[], visibility:list=None,
                 sandbox:bool=None, cgo:bool=False, filter_srcs:bool=True, external:bool=False, timeout:int=0,
                 labels:list&features&tags=None, static:bool=CONFIG.GO_DEFAULT_STATIC, definitions:str|list|dict=None,
                 test_only=True):
    """Defines a Go test suite that will be run as a benchmark.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      cgo (bool): True if this test depends on a cgo_library.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      external (bool): True if this test is external to the library it's testing, i.e. it uses the
                       feature of Go that allows it to be in the same directory with a _test suffix.
      timeout (int): Timeout in seconds to allow the test to run for.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
       test_only (bool): If True, is only visible to test rules.
    """
    # Unfortunately we have to recompile this to build the test together with its library.
    lib_rule = go_library(
        name = '_%s#lib' % name,
        srcs = srcs,
        out = name + ('_lib.a' if cgo else '.a'),
        deps = deps,
        filter_srcs = filter_srcs,
        _all_srcs = not external,
        _link_extra = False,
        complete = False,
        labels = labels,
        test_only = test_only,
    )
    if cgo:
        lib_rule = _merge_cgo_obj(
            name = name,
            tag = 'cgo',
            a_rule = lib_rule,
            visibility = visibility,
            labels = ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)] + labels,
            deps = deps,
            test_only = test_only,
        )
    main_rule = go_test_main(
        name = name,
        _tag = 'main',
        srcs = srcs,
        deps = deps,
        benchmark=True,
        _post_build = lambda name, output: _replace_test_package(name, output, static, definitions=definitions, cgo=cgo),
        test_only = test_only,
    )
    deps += [lib_rule]
    lib_rule = go_library(
        name='_%s#main_lib' % name,
        srcs=[main_rule],
        deps=deps,
        _generate_import_config=False,
        labels = labels,
        test_only = test_only,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, gcov=cgo)

    return build_rule(
        name=name,
        srcs=[lib_rule],
        data=data,
        deps=deps,
        outs=[name],
        tools=tools,
        cmd=cmds,
        visibility=visibility,
        test_sandbox=sandbox,
        test_timeout=timeout,
        requires=['go', 'test'],
        labels=labels,
        binary=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
        test_only=test_only,
    )

def go_test_main(name:str, srcs:list, test_only:bool=False,
                 deps:list=[], visibility:list=None, _post_build:function=None, _tag=None, benchmark=False,
                 labels:list=[]):
    """Outputs the main file for a Go test.

    This essentially does the test discovery and templates out the entry point from it. Note that
    it only generates the main; you will likely need to arrange for compilation of the inputs via
    a separate go_library rule.

    Args:
      name: Name of the rule
      srcs: Source .go files that define the tests.
      test_only: If True, can only be consumed by tests (or other test_only rules).
      deps: Any additional dependencies
      visibility: Visibility of the rule.
      labels: Any labels to apply to this rule.
    """
    cmd = f'"$TOOLS" --import_path "{CONFIG.GO_IMPORT_PATH}" -o $OUT'
    if benchmark:
        cmd = f'{cmd} --benchmark'
    cmds = {
        'dbg': f'{cmd} $SRCS',
        'opt': f'{cmd} $SRCS',
    }

    if not benchmark:
        cmds['cover'] = f'{cmd} --dir . $SRCS'

    return build_rule(
        name = name,
        tag = _tag,
        srcs = srcs,
        outs = [name + '_main.go'],
        deps = deps,
        cmd = cmds,
        needs_transitive_deps = True,  # Need all dependencies to template coverage variables
        requires = ['go', 'go_src'],
        test_only = test_only,
        tools = [CONFIG.GO_TEST_TOOL],
        post_build = _post_build,
        visibility = visibility,
        labels = labels,
    )


def cgo_test(name:str, srcs:list, data:list=None, deps:list=None, visibility:list=None,
             flags:str='', sandbox:bool=None, timeout:int=0, flaky:bool|int=0,
             test_outputs:list=None, labels:list&features&tags=None, size:str=None, static:bool=False):
    """Defines a Go test rule over a cgo_library.

    If the library you are testing is a cgo_library, you must use this instead of go_test.
    It's ok to depend on a cgo_library though as long as it's not the same package
    as your test; in that (any any other case of testing a go_library) you must use go_test.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     It may not be easy to make cgo tests work when linked statically; depending
                     on your toolchain it may not be possible or may fail.
    """
    return go_test(
        name = name,
        srcs = srcs,
        data = data,
        deps = deps,
        cgo = True,
        static = static,
        visibility = visibility,
        flags = flags,
        sandbox = sandbox,
        timeout = timeout,
        flaky = flaky,
        test_outputs = test_outputs,
        labels = labels,
        size = size,
    )


def _remove_redundant_outs(outs):
    """
      Given a list of proposed outputs for this rule (which may be paths to .a
      files or directories), returns outputs that aren't contained within other

      outputs - e.g.:
        remove_redundant_outs(["x/y", "x/z.a", "x/p/q/r", "x/p/q"])
      returns
        ["x/y", "x/z.a", "x/p/q"]
    """
    new_outs = {r: True for r in outs}
    for r in new_outs.keys():
        dirs = r.split("/")
        for i in range(1, len(dirs)):
            root = "/".join(dirs[0:i])
            if new_outs.get(root):
                new_outs[r] = False
    return [r for r in new_outs.keys() if new_outs[r]]

def _go_install_module(name:str, module:str, install:list, src:str, outs:list, deps:list, binary:bool, visibility:list,
                       test_only:bool, licences:list, linker_flags:list, env:dict):
    cmd = [
        _set_go_env(),
        _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"'),
        _aggregate_import_cfg_cmd(),
        f"$TOOLS_GO_INSTALL --src_root=$(location {src}) --ld_flags=LD_FLAGS --module_name={module} --importcfg=importconfig --go_tool=$TOOLS_GO --cc_tool=$TOOLS_CC --out=pkg/{CONFIG.GOOS}_{CONFIG.GOARCH} " + " ".join(install),
        "cat LD_FLAGS",
    ]

    if binary:
        outs = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/bin/{name}']
    else:
        outs = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/{out}' for out in _remove_redundant_outs(outs)]

    return build_rule(
        name = name,
        tag = "a_rule" if not binary else None,
        outs = outs,
        deps = deps,
        srcs = [src],
        tools = {
            'go': [CONFIG.GO_TOOL],
            'go_install': [CONFIG.GO_INSTALL_TOOL],
            # TODO(jpoole): this should be optional
            'cc': [CONFIG.CGO_CC_TOOL],
        },
        visibility = visibility,
        building_description = 'Compiling...',
        cmd = ' && '.join(cmd),
        binary = binary,
        requires = ['go', 'go_src'],
        test_only = test_only,
        labels = ['link:plz-out/go'] + [f'cc:ld:{f}' for f in linker_flags],
        needs_transitive_deps = True,
        licences = licences,
        post_build = _add_ld_flags,
        env = env,
    )

def _add_ld_flags(name:str, stdout:list):
    flags = [f"cc:ld:{f}" for f in " ".join(stdout).split(" ") if f]

    for f in flags:
        add_label(name, f)


def _go_install(name:str, get_roots:list, install:list, binary:bool, srcs:list, outs:list, deps:list, test_only:bool,
               visibility:list, licences:list, env:dict):
    # Now compile it in a separate step.
    install_cmd = ' '.join(install or [])
    cmd = [
        'export GOPATH="$(find \"$TMP_DIR\" \( -name src -o -name pkg \) -exec dirname {} \; | sort | uniq | tr \'\\n\' \':\' | sed \'s/:$//\')" GO111MODULE="off"',
        '"$TOOLS_GO" install -gcflags "-trimpath \\\"$TMP_DIR\\\"" -asmflags "-trimpath \\\"$TMP_DIR\\\"" ' + install_cmd,
        ]
    if CONFIG.GOROOT:
        cmd = [f'export GOROOT={CONFIG.GOROOT}'] + cmd
    if package_name():
        cmd += [
            # The outputs tend to end up in subdirectories (Go seems to match them to the location the source came from)
            'rm -rf bin' if binary else 'rm -rf pkg',
            'mv "$PKG_DIR/bin" .' if binary else 'mv "$PKG_DIR/pkg" .',
        ]

    if binary:
        outs = ['bin/' + name]
    else:
        outs = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/{out}' for out in outs]
        # Outputs are created one directory down from where we want them.
        # For most it doesn't matter but the top-level one will get lost.
        pkg_get_roots = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/{getroot}' for getroot in get_roots]
        cmd += [f' if [ -f {out}.a ]; then mkdir -p {out} && cp {out}.a {out}; fi' for out in pkg_get_roots]

    return build_rule(
        name = name,
        tag = "a_rule" if not binary else None,
        outs = _remove_redundant_outs(outs),
        deps = deps,
        srcs = srcs,
        tools = {
            'go': [CONFIG.GO_TOOL],
        },
        visibility = visibility,
        building_description = 'Compiling...',
        cmd = ' && '.join(cmd),
        binary = binary,
        requires = ['go', 'go_src'],
        test_only = test_only,
        labels = ['link:plz-out/go'],
        needs_transitive_deps = True,
        licences = licences,
        env = env,
    )

def go_mod_download(name:str, module:str, version:str, test_only:bool=False, visibility:list=None, strip:list=[],
                    licences:list=None, hashes:list=None, labels:list=[], _tag:str='', deps:list=[],
                    please_go_install:bool=CONFIG.FF_PLEASE_GO_INSTALL):
    """Downloads a third-party Go module using `go mod download`

    This rule is typically used in conjunction with go_module() to resolve cyclic dependencies between modules. This rule
    can be passed to go_module() via the download param which enables multiple go_module() rules to compile parts of the
    whole module. It can also be useful to download from a fork of a module where the import path doesn't match the
    repo path.

    Args:
      name (str): Name of the rule
      module (str): The module to download
      version (str): The version of the module.
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If true this rule will only be visible to tests.
      strip (list ): List of paths to strip from the target after downloading but before building it.
      hashes (list): List of hashes to verify the downloaded sources against.
      licences (list): Licences this rule is subject to.
      labels (list): Labels to apply to this rule.
      please_go_install (bool): Whether this module is going to be consumed by please_go_install. When set, this rule
                                will output into a folder based on it's name completely avoiding issues with multiple
                                rules outputting into the same location.
    """
    cmds = [
        f'export MOD_DIR=$($TOOL mod download -x -modcacherw -json {module}@{version} | ' 'awk -F\\" \'/"Dir": / { print $4 }\')',
        "cp -r $MOD_DIR $OUT",
    ] + [f'rm -rf $OUT/{s}' for s in strip]

    return build_rule(
        name = name,
        tag = _tag,
        outs = [name] if please_go_install else [f'src/{module}'],
        tools = [CONFIG.GO_TOOL],
        building_description = 'Fetching...',
        cmd = ' && '.join(cmds),
        requires = ['go_src'],
        test_only = test_only,
        labels = labels + ['link:plz-out/go'],
        hashes = hashes,
        sandbox = False,
        licences = licences,
        visibility = visibility,
        deps = deps,
    )

def go_module(name:str='', module:str, version:str='', download:str='', deps:list=[], exported_deps:list=[],
              visibility:list=None, test_only:bool=False, binary:bool=False, install:list=[], hashes:list=None,
              licences:list=None, linker_flags:list=[], please_go_install:bool=CONFIG.FF_PLEASE_GO_INSTALL,
              strip:list=[], env:dict={}):
    """Defines a dependency on a third-party Go module.

    Note that unlike a normal `go get` call, this does *not* install transitive dependencies.
    You will need to add those as separate rules; `go list -f '{{.Deps}}' <package>` can be
    useful to discover what they should be.

    This rule is different to go_get() in that it is go module aware. It handles vanity imports and major versions
    correctly so is the recommended approach.

    Args:
      name (str): Name of the rule
      module (str): The module to compile
      version (str): The version of the module.
      download (str): Can be provided instead of version to manage downloading the module separately. This must be a
                      rule that has a single output containing the go sources of the module.  Usually this will
                      be a go_mod_download() rule however it doesn't have to be. This can be used for a number of
                      purposes but primarily it is for resolving cyclic dependencies between modules.
      deps (list): Dependencies
      exported_deps (list): Dependencies to make available to anything using this rule.
      visibility (list): Visibility specification
      binary (bool): True if the output of the rule is a binary.
      test_only (bool): If true this rule will only be visible to tests.
      install (list | dict): Only install listed (sub)packages. If the dict form is used, each key should
                             correspond to a target in 'get', with the value defining the list of packages
                             to install for that target. Specify the empty string as an element in the list
                             to install a target's root package.
      strip (list ): List of paths to strip from the target after downloading but before building it.
      hashes (list): List of hashes to verify the downloaded sources against.
      licences (list): Licences this rule is subject to.
      linker_flags (list): Any additional linker flags to apply. Linker flags defined in the module itself will
                           automatically be collected so this is typically not necessary.
      env (dict): Any env variables to set during build time. This can be useful to set CGO_CFLAGS etc. to control
                  aspects of compilation.
      please_go_install (bool): Whether to use please_go_install instead of  `go install` to compile the module. This
                                feature is still maturing however avoids a number of issues with relying on `go install`
                                and will become the default in a future release.
    """
    if version and download:
        raise ParseError("You have provided both version and download. Must provided one or the other.")

    if not download and not version:
        raise ParseError("Either version or download should be provided")

    install = [f"{module}/{i}" if i != "." else module for i in install]

    if not download:
        download = go_mod_download(
            name = name,
            _tag = "get",
            module = module,
            version = version,
            deps = deps,
            test_only = test_only,
            visibility = visibility,
            licences = licences,
            hashes = hashes,
            strip = strip,
            please_go_install=please_go_install,
        )
    outs = []
    if not binary:
        if not install:
            outs = [f"{module}.a"]
        else:
            for i in install:
                if i == module or i == f"{module}/.":
                    outs += [module + ".a"]
                elif i == "...":
                    outs = [module]
                elif i.endswith("/..."):
                    outs += [i.removesuffix("/...")]
                else:
                    outs += [f"{i}.a"]

    if please_go_install:
        a_rule = _go_install_module(
            name = name,
            module = module,
            install = install or [module],
            binary = binary,
            src = download,
            outs = outs,
            deps = deps + exported_deps,
            test_only = test_only,
            visibility = visibility,
            licences = licences,
            linker_flags = linker_flags,
            env = env,
        )
    else:
        a_rule = _go_install(
            name = name,
            get_roots = [module],
            install = install or [module],
            binary = binary,
            srcs = [download],
            outs = outs,
            deps = deps + exported_deps,
            test_only = test_only,
            visibility = visibility,
            licences = licences,
            env = env,
        )

    if binary:
        return a_rule

    import_config = build_rule(
        name=name,
        tag='import_config',
        deps = [a_rule],
        visibility = visibility,
        test_only = test_only,
        cmd = _generate_pkg_import_cfg_cmd('"$OUT"', '"$PKG_DIR"', True),
        outs = [f'{name}.importconfig'],
    )
    exported_deps = exported_deps + [import_config] if exported_deps else [import_config]

    return filegroup(
        name = name,
        srcs = [a_rule],
        deps = deps,
        exported_deps = exported_deps,
        provides = {
            "go": f":{name}", # provide the filegroup otherwise exported deps don't work
            "go_src": download,
        },
        visibility = visibility,
        needs_transitive_deps = True,
        test_only = test_only,
        requires = ['go'],
        binary = binary,
    )


def go_get(name:str, get:str|list, repo:str='', deps:list=[], exported_deps:list=[],
           visibility:list=None, patch:str|list|dict=None, binary:bool=False, test_only:bool&testonly=False,
           install:list|dict=None, revision:str|list=None, strip:list|dict=None, hashes:list=None,
           extra_outs:list=[], licences:list=None, module_major_version:str|list='', env:dict={}):
    """Defines a dependency on a third-party Go library.

    Note that unlike a normal `go get` call, this does *not* install transitive dependencies.
    You will need to add those as separate rules; `go list -f '{{.Deps}}' <package>` can be
    useful to discover what they should be.

    Note also that while a single go_get is sufficient to compile all parts of a library,
    one may also want separate ones for a binary. Since two rules can't both output the same
    source files (and you only want to download them once anyway) you should handle that by
    marking the non-binary rule as a dependency of the binary one - if you don't there may
    be warnings issued about conflicting output files.

    Args:
      name (str): Name of the rule
      get (str): Target to get (eg. "github.com/gorilla/mux"). Can also be a list of multiple in
                 which case they are fetched separately and compiled together, which can be useful
                 for avoiding issues with circular dependencies.
      repo (str): Location of a Git repository to fetch from if different from get. To enable vendoring, this can also
                  be a build rule. The build rule must produce a single output in the format `src/{module}`
                  e.g. src/golang.org/x/net. This can also be an absolute path to the repo on disk
                  e.g. /home/you/git/xnet.
      deps (list): Dependencies
      exported_deps (list): Dependencies to make available to anything using this rule.
      visibility (list): Visibility specification
      patch (str | list | dict): Patch file(s) to apply. If the dict form is used, each key should correspond
                                 to a target in 'get', with the value defining the patch file(s) to apply to
                                 that target.
      binary (bool): True if the output of the rule is a binary.
      test_only (bool): If true this rule will only be visible to tests.
      install (list | dict): Only install listed (sub)packages. If the dict form is used, each key should
                             correspond to a target in 'get', with the value defining the list of packages
                             to install for that target. Specify the empty string as an element in the list
                             to install a target's root package.
      revision (str): Git hash to check out before building. Only works for git at present,
                      not for other version control systems.
      strip (list | dict): List of paths to strip from the target after downloading but before building it.
                           If the dict form is used, each key should correspond to a target in 'get', with
                           the value defining the paths to strip from that target.
      hashes (list): List of hashes to verify the downloaded sources against.
      extra_outs (list): List of additional output files after the compile.
      licences (list): Licences this rule is subject to.
      module_major_version (str): The go module major version. This rule is not module aware so when a go module does
                                  a major version release, the import path may no longer match the repository structure.
                                  This rule allows us to map the source path in the repo github.com/some/repo/main.go to
                                  the actual source path github.com/some/repo/v2/main.go.
      env (dict): Any env variables to set during build time. This can be useful to set CGO_CFLAGS etc. to control
                  aspects of compilation.
    """
    def get_param_as_list(value, key):
        if not value:
            return []
        elif isinstance(value, str):
            return [value]
        elif isinstance(value, list):
            return value
        elif isinstance(value, dict):
            v = value.get(key)
            if not v:
                return []
            if isinstance(v, str):
                return [v]
            elif isinstance(v, list):
                return v
            else:
                error(f"get_param_as_list: unexpected type %s" % type(v))
        else:
            error(f"get_param_as_list: unexpected type %s" % type(value))

    go_rule = f':{name}'
    if isinstance(get, str):
        get = [get]
        revision = [revision]
        tags = ['get']
        module_major_version = [module_major_version]
    else:
        tags = [g.replace('/', '_') for g in get]
        revision = revision or [None for g in get]
        module_major_version = module_major_version or ['' for g in get]
    all_installs = []
    outs = extra_outs
    get_roots = []
    provides = {}
    srcs = []
    for getone, revision, tag, module_major_version in zip(get, revision, tags, module_major_version):
        get_rule, getroot = _go_get_download(
            name = name,
            tag = tag,
            get = getone,
            repo = repo,
            patch = get_param_as_list(patch, getone),
            hashes = hashes,
            test_only = test_only,
            revision = revision,
            strip = get_param_as_list(strip, getone),
            licences = licences,
            module_major_version = module_major_version,
        )

        get_roots += [getroot]
        srcs += [get_rule]
        provides = {'go': go_rule, 'go_src': get_rule}
        installone = get_param_as_list(install, getone)
        if not install or (len(get) > 1 and isinstance(install, list)):
            outs += [getroot]
        else:
            for i in installone:
                if not i or i == ".":
                    outs += [getroot + ".a"]
                elif i == "...":
                    get_roots += [getroot]
                    outs += [getroot]
                elif i.endswith("/..."):
                    out = getroot + "/" + i.removesuffix("/...")
                    get_roots += [out]
                    outs += [out]
                else:
                    outs += [f"{getroot}/{i}.a"]

        if installone:
            all_installs += [i if i.startswith(getroot) else (getroot + '/' + i) for i in installone]
        else:
            all_installs += [getone]

    # in case of installing packages using other package sources
    if not get and not install:
        raise ParseError("must provide get or install!")
    else:
        if not srcs and not binary:
            # we are going to infer the getroot name from the 1st install dependency
            getroot = install[0][:-4] if install[0].endswith('/...') else install[0]
            # NOTE: for this case in the install list I'm expecting full package names
            outs += [i[:-4] if i.endswith('/...') else i+".a" for i in install]
            provides = {'go': go_rule} # I can't find the sources

    a_rule = _go_install(
        name,
        get_roots=get_roots,
        install = all_installs or install,
        binary = binary,
        srcs = srcs,
        outs = outs,
        deps = deps + exported_deps,
        test_only = test_only,
        visibility = visibility,
        licences = licences,
        env=env,
    )

    if binary:
        return a_rule

    import_config = build_rule(
        name=name,
        tag='import_config',
        deps = [a_rule],
        visibility = visibility,
        test_only = test_only,
        cmd = _generate_pkg_import_cfg_cmd('"$OUT"', '"$PKG_DIR"', True),
        outs = [f'{name}.importconfig'],
    )
    exported_deps = exported_deps + [import_config] if exported_deps else [import_config]

    return filegroup(
        name = name,
        srcs = [a_rule],
        deps = deps,
        exported_deps = exported_deps,
        provides = provides,
        visibility = visibility,
        needs_transitive_deps = True,
        test_only = test_only,
        requires = ['go'],
        binary = binary,
    )



def _go_get_download(name:str, tag:str, get:str, repo:str='', patch:list=[], hashes:list=None,
                     test_only:bool&testonly=False, revision:str=None, strip:list=None,
                     labels:list=[], licences:list=None, module_major_version:str):
    if hashes and not revision:
        log.warning("You shouldn't specify hashes on go_get without specifying revision as well")
    labels = [f'go_get:{get}@{revision}' if revision else f'go_get:{get}']
    getroot = get[:-4] if get.endswith('/...') else get
    subdir = 'src/' + getroot
    revision = revision or 'master'

    # if the repo is a build rule, just return that assuming it outputs in the correct format
    if repo.startswith("//") or repo.startswith(":"):
        return repo, getroot

    # Allow overriding with locally cloned repos
    if repo.startswith('/'):
        return build_rule(
            name = name,
            tag = tag,
            system_srcs = [repo],
            outs = [subdir],
            cmd = 'cp -r "$SRCS" "$OUTS"',
            test_only = test_only,
        ), getroot

    # Some special optimisation for github, which lets us download zipfiles at a particular sha instead of
    # cloning the whole repo. Obviously that is a lot faster than cloning entire repos.
    if repo.startswith('github.com'):
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, repo, revision, module_major_version)
    elif get.startswith('github.com'):
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, getroot, revision, module_major_version)
    elif get.startswith('golang.org/x/') and not repo:
        # We know about these guys...
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, 'github.com/golang/' + getroot[len('golang.org/x/'):], revision, module_major_version)
    elif get.startswith('google.golang.org/grpc') and not repo:
        cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, 'github.com/grpc/grpc-go' + getroot[len('google.golang.org/grpc'):], revision, module_major_version)
    else:
        get_deps = []
        if repo:
            # we've been told exactly where to get the source from.
            cmd = [f'git clone --branch {revision} --depth=1 --shallow-submodules --no-tags {repo} src/{getroot}']
        else:
            # Ultimate fallback to go get.
            # This has some more restrictions than the above (e.g. go get won't fetch a directory
            # with no Go files in it, even if passed -d).
            cmd = [
                'rm -rf src pkg',
                'export GOPATH="$TMP_DIR" GO111MODULE="off"',
                '$TOOL get -d ' + get,
            ]
        if revision:
            # Annoyingly -C does not work on git checkout :(
            cmd += [f'(cd {subdir} && git checkout -q {revision})']
        cmd += ['find . -name .git | xargs rm -rf']
        tools = [CONFIG.GO_TOOL]
    if patch:
        cmd += [f'for p in "$TMP_DIR"/$SRCS_PATCH; do patch -d {subdir} -p1 < $p; done']
    if strip:
        cmd += [f'rm -rf {subdir}/{s}' for s in strip]
    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            'patch': patch,
            'get': get_deps,
        },
        outs = [subdir],
        tools = tools,
        building_description = 'Fetching...',
        cmd = ' && '.join(cmd),
        requires = ['go'],
        test_only = test_only,
        labels = labels + ['link:plz-out/go'],
        hashes = hashes,
        sandbox = False,
        licences = licences,
    ), getroot


def _go_github_repo_cmd(name, get, repo, revision, module_major_version):
    """Returns a partial command to fetch a Go repo from Github."""
    parts = get.split('/')
    out = '/'.join(parts[:3])
    if repo.count('/') >= 2:
        parts = repo.split('/')
        repo = '/'.join(parts[:3])
        dest = parts[2]
    else:
        dest = parts[-1]
    remote_rule = remote_file(
        name = name + '-' + parts[-1],
        _tag = 'download',
        url = f'https://{repo}/archive/{revision}.zip',
        out = name + '-' + parts[-1] + '.zip',
    )

    cmds = [
        'rm -rf src/' + out,
        '"$TOOL" x $SRCS_GET',
    ]
    if module_major_version:
        cmds += [
            f'mkdir -p src/{out}',
            f'mv {dest}*/ src/{out}/{module_major_version}'
        ]
    else:
        cmds += [f'mv {dest}*/ src/{out}']

    return cmds, [remote_rule], [CONFIG.JARCAT_TOOL]


def _set_go_env():
    if CONFIG.GOROOT:
        go_root = CONFIG.GOROOT
    elif CONFIG.GO_TOOL.startswith(":") or CONFIG.GO_TOOL.startswith("//"):
        label, _, _ = CONFIG.GO_TOOL.rpartition('|')
        go_root = f'$(dirname $(dirname $TOOLS_GO))'
    else:
        go_root = '$("$TOOLS_GO" env GOROOT)'
    cmd = f'export GOPATH=$TMP_DIR && export GOROOT={go_root}'
    if CONFIG.CGO_ENABLED:
        return f'export CGO_ENABLED={CONFIG.CGO_ENABLED} && {cmd}'
    return cmd

def _go_library_cmds(complete=True, all_srcs=False, cover=True, filter_srcs=True, abi=False):
    """Returns the commands to run for building a Go library."""
    filter_cmd = 'export SRCS="$(\"${TOOLS_FILTER}\" ${SRCS})"; ' if filter_srcs else ''
    # Invokes the Go compiler.
    complete_flag = '-complete ' if complete else ''
    out_cmd = ' -o "$OUTS_O" -symabis $SRCS_ABI -asmhdr "$OUTS_H"' if abi else ' -o "$OUT"'
    compile_cmd = f'"$TOOLS_GO" tool compile -importcfg importconfig -trimpath "$TMP_DIR" {complete_flag} -pack {out_cmd}'
    # Annotates files for coverage.
    cover_cmd = 'for SRC in $SRCS; do BN=$(basename $SRC); "$TOOLS_GO" tool cover -mode=set -var=GoCover_${BN//[.-]/_} $SRC > _tmp.go && mv -f _tmp.go $SRC; done'

    gen_import_cfg = _set_go_env() + ' && ' + _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')
    gen_import_cfg += ' && ' + _aggregate_import_cfg_cmd()
    prefix = ('export SRCS="$PKG_DIR/*.go"; ' + gen_import_cfg) if all_srcs else gen_import_cfg
    cmds = {
        'dbg': f'{prefix}; {filter_cmd}{compile_cmd} -N -l $SRCS',
        'opt': f'{prefix}; {filter_cmd}{compile_cmd} $SRCS',
    }
    if cover:
        cmds['cover'] = f'{prefix}; {filter_cmd}{cover_cmd} && {compile_cmd} $SRCS'
    return cmds


def _go_binary_cmds(static=False, ldflags='', pkg_config='', definitions=None, gcov=False):
    """Returns the commands to run for linking a Go binary."""

    _link_cmd = f'"$TOOLS_GO" tool link -importcfg importconfig -tmpdir "$TMP_DIR" -extld "$TOOLS_LD" -o "$OUT"'

    gen_import_cfg = _set_go_env() + ' && ' + _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')
    gen_import_cfg += ' && ' + _aggregate_import_cfg_cmd()

    linkerdefs = []
    if definitions is None:
        pass
    elif isinstance(definitions, str):
        linkerdefs += [f'{definitions}']
    elif isinstance(definitions, list):
        linkerdefs += [f'{linkerdef}' for linkerdef in definitions]
    elif isinstance(definitions, dict):
        linkerdefs = [k if v is None else f'{k}={v}' for k, v in sorted(definitions.items())]

    defs = ' '.join([f'-X "{linkerdef}"' for linkerdef in linkerdefs])

    if static:
        flags = f'-linkmode external -extldflags "-static {ldflags} {pkg_config}"'
    elif ldflags or pkg_config:
        flags = f'-extldflags "{ldflags} {pkg_config}"'
    else:
        flags = f''

    if len(defs) > 0:
        flags += " " + defs

    cmds = {
        'dbg': f'{gen_import_cfg} && {_link_cmd} {flags} $SRCS',
        'opt': f'{gen_import_cfg} && {_link_cmd} {flags} -s -w $SRCS',
    }
    if gcov and CONFIG.CPP_COVERAGE:
        cmds['cover'] = f'{gen_import_cfg} && {_link_cmd} {flags} -extldflags="-lgcov" $SRCS'

    return cmds, {
        'go': [CONFIG.GO_TOOL],
        'ld': [CONFIG.LD_TOOL if CONFIG.LINK_WITH_LD_TOOL else CONFIG.CC_TOOL],
    }


def _go_import_path_cmd(import_path):
    """Returns a partial command which is used for setting up the Go import path."""
    if not import_path:
        return ''
    elif import_path.startswith('/'):
        raise ConfigError('GO_IMPORT_PATH cannot start with a /')
    elif '/' in import_path:
        return ' && mkdir -p %s && ln -s "$TMP_DIR" %s' % (dirname(import_path), import_path)
    else:
        return ' && ln -s "$TMP_DIR" ' + import_path


def _collect_linker_flags(static):
    """Returns a pre-build function to apply transitive linker flags to a go_binary rule."""
    def collect_linker_flags(name):
        ldflags, pkg_config = _get_ldflags_and_pkgconfig(name)
        if ldflags or pkg_config:
            cmds, _ =  _go_binary_cmds(static=static, ldflags=ldflags, pkg_config=pkg_config)
            for k, v in cmds.items():
                set_command(name, k, v)
    return collect_linker_flags


def _get_ldflags_and_pkgconfig(name):
    """Returns the ldflags and pkg-config invocations for a target."""
    labels = get_labels(name, 'cc:')
    ldflags = ' '.join([l[3:] for l in labels if l.startswith('ld:')])
    pkg_config = ' '.join([l[3:] for l in labels if l.startswith('pc:')])
    return (ldflags, f'`pkg-config --libs {pkg_config}`') if pkg_config else (ldflags, '')

def _replace_test_package(name, output, static, definitions, cgo):
    """Post-build function, called after we template the main function.

    The purpose is to replace the real library with the specific one we've
    built for this test which has the actual test functions in it.
    """
    if not name.endswith('#main') or not name.startswith('_'):
        raise ValueError('unexpected rule name: ' + name)
    lib = name[:-5] + '#main_lib'
    new_name = name[1:-5]
    for line in output:
        if line.startswith('Package: '):
            ldflags, pkg_config = _get_ldflags_and_pkgconfig(name)
            pkg_name = line[9:]
            pkg_dir = package_name()

            import_dir = _get_import_path(None)
            import_path = f'{import_dir}/{pkg_name}'
            import_path = _trim_import_path(import_path)
            import_config_cmd = f'rm -f $PKG_DIR/{pkg_name}.importconfig && echo packagefile {import_path}=$PKG_DIR/{new_name}.a > {pkg_name}.importconfig'

            binary_cmds, _ = _go_binary_cmds(static=static, ldflags=ldflags, pkg_config=pkg_config, definitions, cgo)
            for k, v in binary_cmds.items():
                set_command(new_name, k, f'{import_config_cmd} && {v}')

            for k, v in _go_library_cmds().items():
                set_command(lib, k, f'{import_config_cmd} && {v}')
